C51 COMPILER V8.10   SMBUS_HANDLER                                                         02/19/2008 14:38:36 PAGE 1   


C51 COMPILER V8.10, COMPILATION OF MODULE SMBUS_HANDLER
OBJECT MODULE PLACED IN .\SMBus_handler.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\protocols2\SMBus_handler.c BROWSE DEFINE(FEB64,_PCA_INTERNAL_,_SMB_PROTO
                    -COL_,_LTC1669_) DEBUG OBJECTEXTEND PRINT(.\SMBus_handler.lst) OBJECT(.\SMBus_handler.obj)

line level    source

   1          /**********************************************************************************\
   2            Name:         SMBus_handler.c
   3            Created by:   Bahman Sotoodian                Feb/11/2008
   4          
   5          
   6            Contents:     SMBus protocol for T2K-FGD experiment
   7                    (using C8051F133's internal SMBus features)
   8          
   9            Version:    Rev 
  10          
  11            
  12          
  13            $Id:$
  14          \**********************************************************************************/
  15          // --------------------------------------------------------
  16          //  Include files
  17          // --------------------------------------------------------
  18          
  19          #include "../feb64/mscbemb.h"
  20          
  21          #ifdef _SMB_PROTOCOL_
  22          
  23          #include "SMBus_handler.h"
  24          
  25          // --------------------------------------------------------
  26          //  SMBus_Initialization :
  27          //      Bus Initialization sequence
  28          // --------------------------------------------------------
  29          void  SMBus_Init(void)
  30          {
  31   1        // timer 1 is usually initialized by mscbmain.c
  32   1        // If you make no change in that file, you do not need to
  33   1        // activate the following two lines.
  34   1        // TMOD = (TMOD & 0x0F) | 0x20;     // 8 bit auto-reloaded mode
  35   1        // TR1 = 0;                         // Activate timer 1
  36   1        
  37   1        //BS    SMB0CF  = 0x55;     // SMBus configuration
  38   1        //BS    SMB0CF |= 0x80;     // Enable SMBus after all setting done.
  39   1        // SFRPAGE  = CONFIG_PAGE;
  40   1        // P0MDOUT |= 0x0C;
  41   1      
  42   1        // SMBus Clock Setup
  43   1        // SMBus enable, 
  44   1        // Sysclk as clock source
  45   1               SFRPAGE = TMR3_PAGE;
  46   1               TMR3CN  = 0x04;          //Enabling Timer 3 for Bus Free Timeout detection      
  47   1               SFRPAGE = SMB0_PAGE;
  48   1               SMB0CN  = 0x03;     // SMBus Free timeor enable and SMBus Timeout Enable 
  49   1               SMB0CR  = 0xD2;         // Setting the SCL to 1MHz and Setting Bus Free Timeout period 18.5 us   
  50   1           SMB0CN |= 0x40;     // Enable SMBus after all setting done.
  51   1               
  52   1      }
  53          
  54          // --------------------------------------------------------
C51 COMPILER V8.10   SMBUS_HANDLER                                                         02/19/2008 14:38:36 PAGE 2   

  55          //  SMBus_Write_CD :
  56          //      Write a single command and data word to the SMBus as a Master
  57          //
  58          //      Arguments :
  59          //          slave_address   : 7-bit slave address
  60          //          command         : command word
  61          //          value           : data word
  62          //
  63          //      Return    :
  64          //          0               : success
  65          //          non-zero        : error
  66          // --------------------------------------------------------
  67          void SMBus_Start(void)
  68          {
  69   1        SI = 0;
  70   1        STA = 1;    // make Start bit
  71   1        SMBus_SerialInterrupt(); // wait for SMBus interruption..
  72   1        STA = 0;    // clear start bit
  73   1      }
  74          
  75          void SMBus_WriteByte(unsigned char Byte, unsigned char RW_flag)
  76          {
  77   1        SFRPAGE = SMB0_PAGE;  
  78   1        if(RW_flag == WRITE) //write flag on
  79   1        {
  80   2          SMB0DAT = (Byte << 1) & 0xFE;
  81   2        }
  82   1        else if(RW_flag == READ) //read flag on
  83   1        {
  84   2          SMB0DAT = (Byte << 1) | 0x01;
  85   2        }
  86   1        else //if it's just writing a value or command (CMD or VAL)
  87   1        {
  88   2          SMB0DAT = Byte; // Set the SMBus Data to be the desired Byte value
  89   2        }
  90   1        SI = 0;
  91   1        SMBus_SerialInterrupt();  // wait for SMBus interruption. sending the byte..
  92   1      }
  93          
  94          unsigned char SMBus_ReadByte(void)
  95          {
  96   1        SI      = 0;  // clear interrupt flag
  97   1          SMBus_SerialInterrupt();    // wait SMBus interruption. receiving data word ...
  98   1        AA     = 0;        // send back NACK
  99   1          return SMB0DAT; // return the Received Byte
 100   1      }
 101          
 102          void SMBus_Stop(void)
 103          {
 104   1        STO = 1;    // make Stop bit
 105   1        SI = 0;   // clear interrupt flag
 106   1      }
 107          
 108          bit SMBus_SerialInterrupt(void)
 109          {
 110   1        unsigned char startTime = 0;
 111   1      
 112   1        startTime = time();
 113   1      
 114   1        while(SI == 0);
 115   1        {
 116   2          //if SI doesn't turn on for longer than the defined SIwaitTime
C51 COMPILER V8.10   SMBUS_HANDLER                                                         02/19/2008 14:38:36 PAGE 3   

 117   2          if((time() - startTime) > SMBUS_SI_WAITTIME)
 118   2          {
 119   3            return 1; //return 1 as an indication for communication failure
 120   3          }
 121   2        }
 122   1      
 123   1        //if nothing goes wrong and SI does turn on
 124   1        return 0; //success
 125   1      }
 126          
 127          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    131    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
