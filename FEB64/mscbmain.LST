C51 COMPILER V8.10   MSCBMAIN                                                              02/19/2008 13:55:17 PAGE 1   


C51 COMPILER V8.10, COMPILATION OF MODULE MSCBMAIN
OBJECT MODULE PLACED IN mscbmain.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE mscbmain.c BROWSE DEFINE(FEB64,_PCA_INTERNAL_,_SMB_PROTOCOL_,_LTC1669_) DEB
                    -UG OBJECTEXTEND

line level    source

   1          /********************************************************************\
   2          
   3            Name:         mscbmain.c
   4            Created by:   Stefan Ritt
   5          
   6            Contents:     Midas Slow Control Bus protocol main program
   7          
   8            $Id: mscbmain.c 38 2008-01-29 23:19:00Z fgddaq $
   9          
  10          \********************************************************************/
  11          
  12          #include <stdio.h>
  13          #include <string.h>
  14          #include <intrins.h>
  15          #include <stdlib.h>
  16          #include "mscbemb.h"
  17          
  18          /* GET_INFO attributes */
  19          #define GET_INFO_GENERAL  0
  20          #define GET_INFO_VARIABLE 1
  21          
  22          /* Variable attributes */
  23          #define SIZE_8BIT         1
  24          #define SIZE_16BIT        2
  25          #define SIZE_24BIT        3
  26          #define SIZE_32BIT        4
  27          
  28          /* Address modes */
  29          #define ADDR_NONE         0
  30          #define ADDR_NODE         1
  31          #define ADDR_GROUP        2
  32          #define ADDR_ALL          3
  33          
  34          /*---- functions and data in user part -----------------------------*/
  35          
  36          void user_init(unsigned char init);
  37          void user_write(unsigned char index) reentrant;
  38          unsigned char user_read(unsigned char index);
  39          void user_loop(void);
  40          
  41          extern MSCB_INFO_VAR *variables;
  42          extern unsigned char idata _n_sub_addr;
  43          
  44          extern char code node_name[];
  45          
  46          char code svn_rev_main[] = "$Rev: 38 $";
  47          
  48          /*------------------------------------------------------------------*/
  49          
  50          /* funtions in mscbutil.c */
  51          extern bit lcd_present;
  52          
  53          #if defined(UART1_DEVICE)
              extern void rs232_output(void);
C51 COMPILER V8.10   MSCBMAIN                                                              02/19/2008 13:55:17 PAGE 2   

              #endif
  56          
  57          /* forward declarations */
  58          void flash_upgrade(void);
  59          void send_remote_var(unsigned char i);
  60          
  61          /*------------------------------------------------------------------*/
  62          
  63          /* variables in internal RAM (indirect addressing) */
  64          
  65          #if defined(CPU_C8051F020) || defined(CPU_C8051F120)
  66          unsigned char xdata in_buf[64], out_buf[64]; /* limited by USB block size */
  67          #else
              unsigned char idata in_buf[20], out_buf[8];
              #endif
  70          
  71          unsigned char idata i_in, last_i_in, final_i_in, i_out, cmd_len;
  72          unsigned char idata crc_code, addr_mode, n_variables;
  73          
  74          /* use absolute value between main program and upgrader */
  75          unsigned char idata _flkey _at_ 0x80;
  76          unsigned char idata n_out _at_ 0x81;
  77          
  78          unsigned char idata _cur_sub_addr, _var_size;
  79          
  80          #ifdef UART1_MSCB
              unsigned char var_to_send = 0xFF;
              #endif
  83          
  84          SYS_INFO sys_info;
  85          
  86          #ifdef HAVE_RTC
              /* buffer for setting RTC */
              unsigned char xdata rtc_bread[6];
              unsigned char xdata rtc_bwrite[6];
              bit rtc_set;
              #endif
  92          
  93          /*------------------------------------------------------------------*/
  94          
  95          /* bit variables in internal RAM */
  96          
  97          unsigned char bdata CSR;        // byte address of CSR consisting of bits below 
  98          
  99          sbit DEBUG_MODE = CSR ^ 0;      // debugging mode
 100          sbit SYNC_MODE = CSR ^ 1;       // turned on in SYNC mode
 101          sbit FREEZE_MODE = CSR ^ 2;     // turned on in FREEZE mode
 102          sbit WD_RESET = CSR ^ 3;        // got rebooted by watchdog reset
 103          
 104          bit addressed;                  // true if node addressed
 105          bit flash_param;                // used for EEPROM flashing
 106          bit flash_program;              // used for upgrading firmware
 107          bit configured_addr;            // TRUE if node address is configured
 108          bit configured_vars;            // TRUE if variables are configured
 109          bit flash_allowed;              // TRUE 5 sec after booting node
 110          bit wrong_cpu;                  // TRUE if code uses xdata and CPU does't have it
 111          
 112          /*------------------------------------------------------------------*/
 113          
 114          /* put on idata not to be erased on reboot */
 115          
 116          void setup(void)
C51 COMPILER V8.10   MSCBMAIN                                                              02/19/2008 13:55:17 PAGE 3   

 117          {
 118   1         unsigned char adr, flags, d;
 119   1         unsigned short i;
 120   1         unsigned char *p;
 121   1                                                                                                                       
 122   1         _flkey = 0;
 123   1      
 124   1         /* first disable watchdog */
 125   1         watchdog_disable();
 126   1      
 127   1         /* Port and oscillator configuration */
 128   1      
 129   1      #if defined(CPU_C8051F120)
 130   1      
 131   1         SFRPAGE   = CONFIG_PAGE;
 132   1        
 133   1         XBR0 = 0x04;                 // Enable XBar, UART0 & UART1
 134   1         XBR1 = 0x00;
 135   1         XBR2 = 0x44;
 136   1      
 137   1      #ifdef TREVAL_12X
                 XBR1 = 0x00;                 // Sysclk (0x80) Disable
                 XBR2 = 0x40;                 // UART1 Disable
                 P0MDOUT |= 0x4;              // P0.2: RS485_ENABLE
                 P1MDOUT = 0x60;              // P1.6..7 : Pushpull LED
                 RS485_ENABLE = 0;            // disable RS485 driver
              #endif
 144   1      
 145   1      #ifdef SCS_210 // run SCS_210 at 24.5 MHz
                 /* Select internal quartz oscillator */
                 SFRPAGE   = LEGACY_PAGE;
                 FLSCL     = 0x00;            // set flash read time for <25 MHz
              
                 SFRPAGE   = CONFIG_PAGE;
                 OSCICN    = 0x83;            // divide by 1
                 CLKSEL    = 0x00;            // select internal oscillator
              #else          // run SCS_1001 at 98 MHz
 154   1         /* Select internal quartz oscillator */
 155   1         SFRPAGE   = LEGACY_PAGE;
 156   1         FLSCL     = 0xB0;            // set flash read time for 100 MHz
 157   1      
 158   1         SFRPAGE   = CONFIG_PAGE;
 159   1         OSCICN    = 0x83;            // divide by 1
 160   1         CLKSEL    = 0x00;            // select internal oscillator
 161   1      
 162   1         PLL0CN    |= 0x01;                   
 163   1         PLL0DIV   = 0x01;            
 164   1         PLL0FLT   = 0x01;
 165   1         PLL0MUL   = 0x04;
 166   1         for (i = 0 ; i < 15; i++);   // Wait 5us for initialization
 167   1         PLL0CN    |= 0x02;
 168   1         for (i = 0 ; i<50000 && ((PLL0CN & 0x10) == 0) ; i++);
 169   1      
 170   1         CLKSEL    = 0x02;            // select PLL as sysclk src
 171   1      #endif
 172   1      
 173   1      #elif defined(CPU_C8051F020)
              
                 XBR0 = 0x04;                 // Enable UART0 & UART1
                 XBR1 = 0x00;
                 XBR2 = 0x44;
              
C51 COMPILER V8.10   MSCBMAIN                                                              02/19/2008 13:55:17 PAGE 4   

                 P0MDOUT = 0x01;              // P0.0: TX = Push Pull
                 P1MDOUT = 0x00;              // P1: LPT
                 P2MDOUT = 0x00;              // P2: LPT
                 P3MDOUT = 0xE0;              // P3.5,6,7: Optocouplers
              
              #ifdef SCS_220
                 P0MDOUT |= 0x40;             // P0.6: RS485_SEC_ENABLE = Push Pull
              #endif
              
                 /* Select external quartz oscillator */
                 OSCXCN = 0x67;               // Crystal mode, Power Factor 22E6
                 OSCICN = 0x08;               // CLKSL=1 (external)
              
              #elif defined(CPU_C8051F310) || defined(CPU_C8051F320)
              
                 XBR0 = 0x01;                 // Enable RX/TX
                 XBR1 = 0x40;                 // Enable crossbar
              
              #ifdef SCS_320
                 P0MDOUT = 0x18;              // P0.3:TX, P0.4:RS485 enable Push/Pull
              #else
                 P0MDOUT = 0x90;              // P0.4:TX, P0.7:RS485 enable Push/Pull
              #endif
              
                 /* Select internal quartz oscillator */
                 OSCICN = 0x83;               // IOSCEN=1, SYSCLK=24.5 MHz
                 CLKSEL = 0x00;               // derive SYSCLK from internal source
              
              #else
              
                 XBR0 = 0x04;                 // Enable RX/TX
                 XBR1 = 0x80;                                   // Pusk SYSCLK to XBR 
                 XBR2 = 0x40;                 // Enable crossbar
              
                 PRT0CF = 0x01;               // P0.0: TX = Push Pull
                 PRT1CF = 0x00;               // P1
                 PRT2CF = 0x00;               // P2  Open drain for 5V LCD
                 PRT3CF = 0x20;               // P3.5: RS485 enable = Push Pull
              
                 /* Select external quartz oscillator */
                 OSCXCN = 0x67;               // Crystal mode, Power Factor 22E6
                 OSCICN = 0x08;               // CLKSL=1 (external)
              
              #endif
 223   1      
 224   1         /* start system clock */
 225   1         sysclock_init();
 226   1      
 227   1         /* enable watchdog with default timeout */
 228   1        // watchdog_enable(0);
 229   1      
 230   1         /* default LED mode */
 231   1         for (i=0 ; i<N_LED ; i++)
 232   1            led_mode(i, 1);
 233   1         
 234   1         /* initialize all memory */
 235   1         CSR = 0;
 236   1         addressed = 0;
 237   1         flash_param = 0;
 238   1         flash_program = 0;
 239   1         flash_allowed = 0;
 240   1         wrong_cpu = 0;
C51 COMPILER V8.10   MSCBMAIN                                                              02/19/2008 13:55:17 PAGE 5   

 241   1         _flkey = 0;
 242   1      
 243   1      #ifdef HAVE_RTC
                 rtc_set = 0;
              #endif
 246   1      
 247   1         RS485_ENABLE = 0;
 248   1         i_in = i_out = n_out = 0;
 249   1         _cur_sub_addr = 0;
 250   1         for (i=0 ; i<sizeof(in_buf) ; i++)
 251   1            in_buf[i] = 0;
 252   1         for (i=0 ; i<sizeof(out_buf) ; i++)
 253   1            out_buf[i] = 0;
 254   1      
 255   1         /* check if we got reset by watchdog */
 256   1      #if defined(CPU_C8051F120)
 257   1         SFRPAGE   = LEGACY_PAGE;
 258   1      #endif
 259   1         WD_RESET = ((RSTSRC & 0x02) == 0 && (RSTSRC & 0x08) > 0);
 260   1      
 261   1         /* initialize UART(s) */
 262   1         uart_init(0, BD_115200);
 263   1      
 264   1      #ifdef UART1_MSCB
                 uart_init(1, BD_115200);
              #endif
 267   1      
 268   1      #ifdef HAVE_LCD
                 lcd_setup();
              #endif
 271   1      
 272   1      #ifdef DYN_VARIABLES
                 setup_variables();
              #endif
 275   1      
 276   1         /* count variables */
 277   1         for (n_variables = _var_size = 0;; n_variables++) {
 278   2            _var_size += variables[n_variables].width;
 279   2            if (variables[n_variables].width == 0)
 280   2               break;
 281   2         }
 282   1      
 283   1         /* check if variables are in xdata and xdata is present */
 284   1         if (n_variables > 0) {
 285   2            p = variables[0].ud;
 286   2            d = *p;
 287   2            *p = 0x55;
 288   2            if (*p != 0x55)
 289   2               wrong_cpu = 1;
 290   2            *p = 0xAA;
 291   2            if (*p != 0xAA)
 292   2               wrong_cpu = 1;
 293   2            *p = d;
 294   2         }
 295   1      
 296   1         /* retrieve EEPROM data */
 297   1      #ifdef CPU_C8051F120
 298   1         SFRPAGE = LEGACY_PAGE;
 299   1      #endif
 300   1         if ((RSTSRC & 0x02) > 0)
 301   1            flags = eeprom_retrieve(1); // vars on cold start
 302   1         else
C51 COMPILER V8.10   MSCBMAIN                                                              02/19/2008 13:55:17 PAGE 6   

 303   1            flags = eeprom_retrieve(0);
 304   1      
 305   1         if ((flags & (1 << 0)) == 0) {
 306   2            configured_addr = 0;
 307   2         
 308   2            /* set initial values */
 309   2            sys_info.node_addr = 0xFFFF;
 310   2            sys_info.group_addr = 0xFFFF;
 311   2            memset(sys_info.node_name, 0, sizeof(sys_info.node_name));
 312   2            strncpy(sys_info.node_name, node_name, sizeof(sys_info.node_name));
 313   2         } else
 314   1            configured_addr = 1;
 315   1      
 316   1         /* store SVN revision */
 317   1         sys_info.svn_revision = (svn_rev_main[6]-'0')*1000+
 318   1                                 (svn_rev_main[7]-'0')*100+
 319   1                                 (svn_rev_main[8]-'0')*10+
 320   1                                 (svn_rev_main[9]-'0');
 321   1      
 322   1         if ((flags & (1 << 1)) == 0) {
 323   2      
 324   2            /* init variables */
 325   2            for (i = 0; variables[i].width; i++)
 326   2               if (!(variables[i].flags & MSCBF_DATALESS)) {
 327   3                  /* do it for each sub-address */
 328   3                  for (adr = 0 ; adr < _n_sub_addr ; adr++) {
 329   4                     memset((char*)variables[i].ud + _var_size*adr, 0, variables[i].width);
 330   4                  }
 331   3               }
 332   2      
 333   2            /* call user initialization routine with initialization */
 334   2            user_init(1);
 335   2      
 336   2            /* write current variables to flash later in main routine */
 337   2            configured_vars = 0;
 338   2         } else {
 339   2            /* call user initialization routine without initialization */
 340   2            user_init(0);
 341   2            configured_vars = 1;
 342   2         }
 343   1      
 344   1         /* Blink LEDs */
 345   1         for (i=0 ; i<N_LED ; i++)
 346   1            led_blink(i, 3, 150);
 347   1      
 348   1      }
 349          
 350          /*------------------------------------------------------------------*/
 351          
 352          unsigned char cur_sub_addr()
 353          {
 354   1         return _cur_sub_addr;
 355   1      }
 356          
 357          /*------------------------------------------------------------------*\
 358          
 359            Serial interrupt
 360          
 361          \*------------------------------------------------------------------*/
 362          
 363          void interprete(void);
 364          
C51 COMPILER V8.10   MSCBMAIN                                                              02/19/2008 13:55:17 PAGE 7   

 365          void serial_int(void) interrupt 4 
 366          {
 367   1         if (TI0) {
 368   2            /* character has been transferred */
 369   2      
 370   2            TI0 = 0;                   // clear TI flag
 371   2      
 372   2            i_out++;                   // increment output counter
 373   2            if (i_out == n_out) {
 374   3               i_out = n_out = 0;      // send buffer empty, clear pointer
 375   3               DELAY_US(10);
 376   3               RS485_ENABLE = 0;       // disable RS485 driver
 377   3            } else {
 378   3               DELAY_US(INTERCHAR_DELAY);
 379   3               SBUF0 = out_buf[i_out]; // send character
 380   3            }
 381   2         }
 382   1      
 383   1         if (RI0) {
 384   2            /* character has been received */
 385   2      
 386   2            if (!RB80 && !addressed) {
 387   3               RI0 = 0;
 388   3               i_in = 0;
 389   3               return;                // discard data if not bit9 and not addressed
 390   3            }
 391   2      
 392   2            RB80 = 0;
 393   2            in_buf[i_in++] = SBUF0;
 394   2            RI0 = 0;
 395   2      
 396   2            if (i_in == 1) {
 397   3               /* check for padding character */
 398   3               if (in_buf[0] == 0) {
 399   4                  i_in = 0;
 400   4                  return;
 401   4               }
 402   3      
 403   3               /* initialize command length if first byte */
 404   3               cmd_len = (in_buf[0] & 0x07) + 2;    // + cmd + crc
 405   3            }
 406   2      
 407   2            if (i_in == 2 && cmd_len == 9) {
 408   3               /* variable length command */
 409   3               cmd_len = in_buf[1] + 3;             // + cmd + N + crc
 410   3            }
 411   2      
 412   2            if (i_in == sizeof(in_buf)) {   // check for buffer overflow
 413   3               i_in = 0;
 414   3               return;                      // don't interprete command
 415   3            }
 416   2      
 417   2            if (i_in < cmd_len)             // return if command not yet complete
 418   2               return;
 419   2      
 420   2            if (in_buf[i_in - 1] != crc8(in_buf, i_in - 1)) {
 421   3               i_in = 0;
 422   3               return;                      // return if CRC code does not match
 423   3            }
 424   2      
 425   2            DELAY_US(INTERCHAR_DELAY);
 426   2      
C51 COMPILER V8.10   MSCBMAIN                                                              02/19/2008 13:55:17 PAGE 8   

 427   2            interprete();             // interprete command
 428   2            i_in = 0;
 429   2         }
 430   1      }
 431          
 432          /*------------------------------------------------------------------*\
 433          
 434            Interprete MSCB command
 435          
 436          \*------------------------------------------------------------------*/
 437          
 438          #pragma NOAREGS
 439          
 440          #include <intrins.h>
 441          
 442          static void send_byte(unsigned char d, unsigned char *crc)
 443          {
 444   1      #ifdef CPU_C8051F120
 445   1         SFRPAGE = UART0_PAGE;
 446   1      #endif
 447   1      
 448   1         if (crc)
 449   1            *crc = crc8_add(*crc, d);
 450   1         DELAY_US(INTERCHAR_DELAY);
 451   1         SBUF0 = d;
 452   1         watchdog_refresh(1);
 453   1         while (!TI0);
 454   1         TI0 = 0;
 455   1      }
 456          
 457          static void send_obuf(unsigned char n)
 458          {
 459   1      #ifdef CPU_C8051F120
 460   1         SFRPAGE = UART0_PAGE;
 461   1      #endif
 462   1      
 463   1         n_out = n;
 464   1         RS485_ENABLE = 1;
 465   1         DELAY_US(INTERCHAR_DELAY);
 466   1         SBUF0 = out_buf[0];
 467   1      }
 468          
 469          void addr_node8(unsigned char mode, unsigned char adr, unsigned char node_addr)
 470          {
 471   1         if (mode == ADDR_NODE) {
 472   2            if (adr >= node_addr &&
 473   2                adr <  node_addr + _n_sub_addr) {
 474   3      
 475   3               addressed = 1;
 476   3               _cur_sub_addr = adr - node_addr;
 477   3               addr_mode = ADDR_NODE;
 478   3            } else {
 479   3               addressed = 0;
 480   3               addr_mode = ADDR_NONE;
 481   3            }
 482   2         } else if (mode == ADDR_GROUP) {
 483   2            if (adr == node_addr) {
 484   3               addressed = 1;
 485   3               _cur_sub_addr = 0;
 486   3               addr_mode = ADDR_GROUP;
 487   3            } else {
 488   3               addressed = 0;
C51 COMPILER V8.10   MSCBMAIN                                                              02/19/2008 13:55:17 PAGE 9   

 489   3               addr_mode = ADDR_NONE;
 490   3            }
 491   2         }
 492   1      }
 493          
 494          void addr_node16(unsigned char mode, unsigned int adr, unsigned int node_addr)
 495          {
 496   1         if (node_addr == 0xFFFF) {
 497   2            if (adr == node_addr) {
 498   3               addressed = 1;
 499   3               _cur_sub_addr = 0;
 500   3               addr_mode = mode;
 501   3            } else {
 502   3               addressed = 0;
 503   3               addr_mode = ADDR_NONE;
 504   3            }
 505   2         } else {
 506   2            if (mode == ADDR_NODE) {
 507   3               if (adr >= node_addr &&
 508   3                   adr <  node_addr + _n_sub_addr) {
 509   4         
 510   4                  addressed = 1;
 511   4                  _cur_sub_addr = adr - node_addr;
 512   4                  addr_mode = ADDR_NODE;
 513   4               } else {
 514   4                  addressed = 0;
 515   4                  addr_mode = ADDR_NONE;
 516   4               }
 517   3            } else if (mode == ADDR_GROUP) {
 518   3               if (adr == node_addr) {
 519   4                  addressed = 1;
 520   4                  _cur_sub_addr = 0;
 521   4                  addr_mode = ADDR_GROUP;
 522   4               } else {
 523   4                  addressed = 0;
 524   4                  addr_mode = ADDR_NONE;
 525   4               }
 526   3            }
 527   2         }
 528   1      }
 529          
 530          void interprete(void) 
 531          {
 532   1         unsigned char crc, cmd, i, j, n, ch, a1, a2;
 533   1         unsigned short size;
 534   1         MSCB_INFO_VAR *pvar;
 535   1         unsigned long idata u;
 536   1      
 537   1         cmd = (in_buf[0] & 0xF8);    // strip length field
 538   1      
 539   1      #ifdef CPU_C8051F120
 540   1         SFRPAGE = UART0_PAGE;        // needed for SBUF0
 541   1      #endif
 542   1      
 543   1         switch (in_buf[0]) {
 544   2         case CMD_ADDR_NODE8:
 545   2            addr_node8(ADDR_NODE, in_buf[1], sys_info.node_addr & 0xFF);
 546   2            break;
 547   2      
 548   2         case CMD_ADDR_NODE16:
 549   2            addr_node16(ADDR_NODE, *(unsigned int *) &in_buf[1], sys_info.node_addr);
 550   2            break;
C51 COMPILER V8.10   MSCBMAIN                                                              02/19/2008 13:55:17 PAGE 10  

 551   2      
 552   2         case CMD_ADDR_BC:
 553   2            addressed = 1;
 554   2            addr_mode = ADDR_ALL;
 555   2            break;
 556   2      
 557   2         case CMD_ADDR_GRP8:
 558   2            addr_node8(ADDR_GROUP, in_buf[1], sys_info.group_addr & 0xFF);
 559   2            break;
 560   2      
 561   2         case CMD_ADDR_GRP16:
 562   2            addr_node16(ADDR_GROUP, *(unsigned int *) &in_buf[1], sys_info.group_addr);
 563   2            break;
 564   2      
 565   2         case CMD_PING8:
 566   2            addr_node8(ADDR_NODE, in_buf[1], sys_info.node_addr & 0xFF);
 567   2            if (addressed) {
 568   3               out_buf[0] = CMD_ACK;
 569   3               send_obuf(1);
 570   3            }
 571   2            break;
 572   2      
 573   2         case CMD_PING16:
 574   2            addr_node16(ADDR_NODE, *(unsigned int *) &in_buf[1], sys_info.node_addr);
 575   2            if (addressed) {
 576   3               out_buf[0] = CMD_ACK;
 577   3               send_obuf(1);
 578   3            }
 579   2            break;
 580   2      
 581   2         case CMD_INIT:
 582   2      #ifdef CPU_C8051F120
 583   2            SFRPAGE = LEGACY_PAGE;
 584   2      #endif
 585   2      
 586   2            RSTSRC = 0x10;         // force software reset
 587   2            break;
 588   2      
 589   2         case CMD_GET_INFO:
 590   2            /* general info */
 591   2      
 592   2            ES0 = 0;                  // temporarily disable serial interrupt
 593   2            crc = 0;
 594   2            RS485_ENABLE = 1;
 595   2      
 596   2            send_byte(CMD_ACK + 7, &crc);      // send acknowledge, variable data length
 597   2      #ifdef HAVE_RTC
                    send_byte(30, &crc);               // send data length
              #else
 600   2            send_byte(24, &crc);               // send data length
 601   2      #endif
 602   2            send_byte(PROTOCOL_VERSION, &crc); // send protocol version
 603   2      
 604   2            send_byte(n_variables, &crc);      // send number of variables
 605   2      
 606   2            send_byte(*(((unsigned char *) &sys_info.node_addr) + 0), &crc);  // send node address
 607   2            send_byte(*(((unsigned char *) &sys_info.node_addr) + 1), &crc);
 608   2      
 609   2            send_byte(*(((unsigned char *) &sys_info.group_addr) + 0), &crc); // send group address
 610   2            send_byte(*(((unsigned char *) &sys_info.group_addr) + 1), &crc);
 611   2      
 612   2            send_byte(*(((unsigned char *) &sys_info.svn_revision) + 0), &crc);   // send svn revision
C51 COMPILER V8.10   MSCBMAIN                                                              02/19/2008 13:55:17 PAGE 11  

 613   2            send_byte(*(((unsigned char *) &sys_info.svn_revision) + 1), &crc);
 614   2      
 615   2            for (i = 0; i < 16; i++)  // send node name
 616   2               send_byte(sys_info.node_name[i], &crc);
 617   2      
 618   2      #ifdef HAVE_RTC
                    for (i = 0; i < 6 ; i++)
                       send_byte(rtc_bread[i], &crc);
              #endif
 622   2      
 623   2            send_byte(crc, NULL);     // send CRC code
 624   2      
 625   2            DELAY_US(10);
 626   2            RS485_ENABLE = 0;
 627   2            ES0 = 1;                  // re-enable serial interrupts
 628   2            break;
 629   2      
 630   2         case CMD_GET_INFO + 1:
 631   2            /* send variable info */
 632   2      
 633   2            if (in_buf[1] < n_variables) {
 634   3               pvar = variables + in_buf[1];
 635   3                                        
 636   3               ES0 = 0;                       // temporarily disable serial interrupt
 637   3               crc = 0;
 638   3               RS485_ENABLE = 1;
 639   3      
 640   3               send_byte(CMD_ACK + 7, &crc);  // send acknowledge, variable data length
 641   3               send_byte(13, &crc);           // send data length
 642   3               send_byte(pvar->width, &crc);
 643   3               send_byte(pvar->unit, &crc);
 644   3               send_byte(pvar->prefix, &crc);
 645   3               send_byte(pvar->status, &crc);
 646   3               send_byte(pvar->flags, &crc);
 647   3      
 648   3               for (i = 0; i < 8; i++)        // send variable name
 649   3                  send_byte(pvar->name[i], &crc);
 650   3      
 651   3               send_byte(crc, NULL);          // send CRC code
 652   3      
 653   3               DELAY_US(10);
 654   3               RS485_ENABLE = 0;
 655   3               ES0 = 1;                       // re-enable serial interrupts
 656   3            } else {
 657   3               /* just send dummy ack */
 658   3               out_buf[0] = CMD_ACK;
 659   3               out_buf[1] = 0;
 660   3               send_obuf(2);
 661   3            }
 662   2      
 663   2            break;
 664   2      
 665   2         case CMD_GET_UPTIME:
 666   2            /* send uptime */
 667   2      
 668   2            u = uptime();
 669   2      
 670   2            out_buf[0] = CMD_ACK + 4;
 671   2            out_buf[1] = *(((unsigned char *)&u) + 0);
 672   2            out_buf[2] = *(((unsigned char *)&u) + 1);
 673   2            out_buf[3] = *(((unsigned char *)&u) + 2);
 674   2            out_buf[4] = *(((unsigned char *)&u) + 3);
C51 COMPILER V8.10   MSCBMAIN                                                              02/19/2008 13:55:17 PAGE 12  

 675   2            out_buf[5] = crc8(out_buf, 5);
 676   2            send_obuf(6);
 677   2            break;
 678   2      
 679   2         case CMD_SET_ADDR:
 680   2      
 681   2            if (in_buf[1] == ADDR_SET_NODE) 
 682   2               /* complete node address */
 683   2               sys_info.node_addr = *((unsigned int *) (in_buf + 2));
 684   2            else if (in_buf[1] == ADDR_SET_HIGH)
 685   2               /* only high byte node address */
 686   2               *((unsigned char *)(&sys_info.node_addr)) = *((unsigned char *) (in_buf + 2));
 687   2            else if (in_buf[1] == ADDR_SET_GROUP)
 688   2               /* group address */
 689   2               sys_info.group_addr = *((unsigned int *) (in_buf + 2));
 690   2      
 691   2            /* copy address to EEPROM */
 692   2            flash_param = 1;
 693   2            _flkey = 0xF1;
 694   2      
 695   2            break;
 696   2      
 697   2         case CMD_SET_NAME:
 698   2            /* set node name in RAM */
 699   2            for (i = 0; i < 16 && i < in_buf[1]; i++)
 700   2               sys_info.node_name[i] = in_buf[2 + i];
 701   2            sys_info.node_name[15] = 0;
 702   2      
 703   2            /* copy address to EEPROM */
 704   2            flash_param = 1;
 705   2            _flkey = 0xF1;
 706   2      
 707   2            break;
 708   2      
 709   2         case CMD_SET_BAUD:
 710   2            led_blink(_cur_sub_addr, 1, 50);
 711   2            uart_init(0, in_buf[1]);
 712   2            break;
 713   2      
 714   2         case CMD_FREEZE:
 715   2            FREEZE_MODE = in_buf[1];
 716   2            break;
 717   2      
 718   2         case CMD_SYNC:
 719   2            SYNC_MODE = in_buf[1];
 720   2            break;
 721   2      
 722   2         case CMD_SET_TIME:
 723   2      #ifdef HAVE_RTC
                    led_blink(0, 1, 50);
                    for (i=0 ; i<6 ; i++)
                       rtc_bwrite[i] = in_buf[i+1];
                    rtc_set = 1;
              #endif
 729   2            break;
 730   2      
 731   2         case CMD_UPGRADE:
 732   2            if (_cur_sub_addr != 0)
 733   2               n = 2; // reject upgrade for sub address
 734   2            else if (flash_allowed == 0)
 735   2               n = 3; // upgrade not yet allowed
 736   2            else
C51 COMPILER V8.10   MSCBMAIN                                                              02/19/2008 13:55:17 PAGE 13  

 737   2               n = 1; // positive acknowledge
 738   2      
 739   2            out_buf[0] = CMD_ACK + 1;
 740   2            out_buf[1] = n;
 741   2            out_buf[2] = crc8(out_buf, 2);
 742   2            send_obuf(3);
 743   2      
 744   2            if (n == 1) {
 745   3               flash_program = 1;
 746   3               _flkey = 0xF1;
 747   3            }
 748   2            break;
 749   2      
 750   2         case CMD_FLASH:
 751   2            flash_param = 1;
 752   2            _flkey = 0xF1;
 753   2            break;
 754   2      
 755   2         case CMD_ECHO:
 756   2            led_blink(0, 1, 50);
 757   2            out_buf[0] = CMD_ACK + 1;
 758   2            out_buf[1] = in_buf[1];
 759   2            out_buf[2] = crc8(out_buf, 2);
 760   2            send_obuf(3);
 761   2            break;
 762   2      
 763   2         }
 764   1      
 765   1         if (cmd == CMD_READ) {
 766   2            if (in_buf[0] == CMD_READ + 1) {  // single variable
 767   3               if (in_buf[1] < n_variables) {
 768   4                  n = variables[in_buf[1]].width;     // number of bytes to return
 769   4      
 770   4                  if (variables[in_buf[1]].flags & MSCBF_DATALESS) {
 771   5                     n = user_read(in_buf[1]);        // for dataless variables, user routine returns bytes
 772   5                     out_buf[0] = CMD_ACK + 7;        // and places data directly in out_buf
 773   5                     out_buf[1] = n;
 774   5      
 775   5                     out_buf[2 + n] = crc8(out_buf, 2 + n);      // generate CRC code
 776   5         
 777   5                     /* send result */
 778   5                     send_obuf(3 + n);
 779   5      
 780   5                  } else {
 781   5      
 782   5                     user_read(in_buf[1]);
 783   5      
 784   5                     ES0 = 0;            // temporarily disable serial interrupt
 785   5                     crc = 0;
 786   5                     RS485_ENABLE = 1;
 787   5         
 788   5                     if (n > 6) {
 789   6                        /* variable length buffer */
 790   6                        send_byte(CMD_ACK + 7, &crc);       // send acknowledge, variable data length
 791   6                        send_byte(n, &crc);                 // send data length
 792   6      
 793   6                        for (i = 0; i < n; i++)             // copy user data
 794   6                           send_byte(((char *) variables[in_buf[1]].ud)[i+_var_size*_cur_sub_addr], &crc);
 795   6                        n++;
 796   6                     } else {
 797   6      
 798   6                        send_byte(CMD_ACK + n, &crc);       // send acknowledge
C51 COMPILER V8.10   MSCBMAIN                                                              02/19/2008 13:55:17 PAGE 14  

 799   6                     
 800   6                        for (i = 0; i < n; i++)             // copy user data
 801   6                           send_byte(((char *) variables[in_buf[1]].ud)[i+_var_size*_cur_sub_addr], &crc);
 802   6                     }
 803   5      
 804   5                     send_byte(crc, NULL);                  // send CRC code
 805   5         
 806   5                     DELAY_US(10);
 807   5                     RS485_ENABLE = 0;
 808   5                     ES0 = 1;            // re-enable serial interrupts
 809   5                  }
 810   4               } else {
 811   4                  /* just send dummy ack to indicate error */
 812   4                  out_buf[0] = CMD_ACK;
 813   4                  send_obuf(1);
 814   4               }  
 815   3      
 816   3            } else if (in_buf[0] == CMD_READ + 2) {   // variable range
 817   3      
 818   3              if (in_buf[1] < n_variables && in_buf[2] < n_variables && in_buf[1] <= in_buf[2]) {
 819   4                  /* calculate number of bytes to return */
 820   4                  for (i = in_buf[1], size = 0; i <= in_buf[2]; i++) {
 821   5                     user_read(i);
 822   5                     size += variables[i].width;
 823   5                  }
 824   4      
 825   4                  ES0 = 0;            // temporarily disable serial interrupt
 826   4                  crc = 0;
 827   4                  RS485_ENABLE = 1;
 828   4      
 829   4                  send_byte(CMD_ACK + 7, &crc);            // send acknowledge, variable data length
 830   4                  if (size < 0x80)
 831   4                     send_byte(size, &crc);                // send data length one byte
 832   4                  else {
 833   5                     send_byte(0x80 | size / 0x100, &crc); // send data length two bytes
 834   5                     send_byte(size & 0xFF, &crc);
 835   5                  }
 836   4      
 837   4                  /* loop over all variables */
 838   4                  for (i = in_buf[1]; i <= in_buf[2]; i++) {
 839   5                     for (j = 0; j < variables[i].width; j++)    // send user data
 840   5                        send_byte(((char *) variables[i].ud)[j+_var_size*_cur_sub_addr], &crc); 
 841   5                  }
 842   4      
 843   4                  send_byte(crc, NULL);       // send CRC code
 844   4      
 845   4                  DELAY_US(10);
 846   4                  RS485_ENABLE = 0;
 847   4                  ES0 = 1;            // re-enable serial interrupts
 848   4               } else {
 849   4                  /* just send dummy ack to indicate error */
 850   4                  out_buf[0] = CMD_ACK;
 851   4                  send_obuf(1);
 852   4               }
 853   3            }
 854   2         }
 855   1      
 856   1         if (cmd == CMD_USER) {
 857   2            led_blink(_cur_sub_addr, 1, 50);
 858   2            n = user_func(in_buf + 1, out_buf + 1);
 859   2            out_buf[0] = CMD_ACK + n;
 860   2            out_buf[n + 1] = crc8(out_buf, n + 1);
C51 COMPILER V8.10   MSCBMAIN                                                              02/19/2008 13:55:17 PAGE 15  

 861   2            send_obuf(n+2);
 862   2         }
 863   1      
 864   1         if (cmd == CMD_WRITE_NA || cmd == CMD_WRITE_ACK) {
 865   2      
 866   2            /* blink LED once when writing data */
 867   2            if (addr_mode == ADDR_NODE)
 868   2               led_blink(_cur_sub_addr, 1, 50);
 869   2            else 
 870   2               for (i=0 ; i<_n_sub_addr ; i++)
 871   2                  led_blink(i, 1, 50);
 872   2      
 873   2            n = in_buf[0] & 0x07;
 874   2      
 875   2            if (n == 0x07) {  // variable length
 876   3               j = 1;
 877   3               n = in_buf[1];
 878   3               ch = in_buf[2];
 879   3            } else {
 880   3               j = 0;
 881   3               ch = in_buf[1];
 882   3            }
 883   2      
 884   2            n--; // data size (minus channel)
 885   2      
 886   2            if (ch < n_variables) {
 887   3         
 888   3               /* don't exceed variable width */
 889   3               if (n > variables[ch].width)
 890   3                  n = variables[ch].width;
 891   3      
 892   3               if (addr_mode == ADDR_NODE)
 893   3                  a1 = a2 = _cur_sub_addr;
 894   3               else {
 895   4                  a1 = 0;
 896   4                  a2 = _n_sub_addr-1;
 897   4               }
 898   3                  
 899   3               for (_cur_sub_addr = a1 ; _cur_sub_addr <= a2 ; _cur_sub_addr++) {
 900   4                  for (i = 0; i < n; i++)
 901   4                     if (!(variables[ch].flags & MSCBF_DATALESS)) {
 902   5                        if (variables[ch].unit == UNIT_STRING) {
 903   6                           if (n > 4)
 904   6                              /* copy bytes in normal order */
 905   6                              ((char *) variables[ch].ud)[i + _var_size*_cur_sub_addr] = 
 906   6                                 in_buf[2 + j + i];
 907   6                           else
 908   6                              /* copy bytes in reverse order (got swapped on host) */
 909   6                              ((char *) variables[ch].ud)[i + _var_size*_cur_sub_addr] = 
 910   6                                 in_buf[i_in - 2 - i];
 911   6                        } else
 912   5                           /* copy LSB bytes, needed for BYTE if DWORD is sent */
 913   5                           ((char *) variables[ch].ud)[i + _var_size*_cur_sub_addr] = 
 914   5                                 in_buf[i_in - 1 - variables[ch].width + i + j];
 915   5                     }
 916   4         
 917   4                  user_write(ch);
 918   4               }
 919   3               _cur_sub_addr = a1; // restore previous value
 920   3         
 921   3      #ifdef UART1_MSCB
                       /* mark variable to be send in main loop */
C51 COMPILER V8.10   MSCBMAIN                                                              02/19/2008 13:55:17 PAGE 16  

                       if (variables[ch].flags & MSCBF_REMOUT)
                          var_to_send = ch;
              #endif
 926   3      
 927   3               if (cmd == CMD_WRITE_ACK) {
 928   4                  out_buf[0] = CMD_ACK;
 929   4                  out_buf[1] = in_buf[i_in - 1];
 930   4                  send_obuf(2);
 931   4               }
 932   3            } else if (ch == 0xFF) {
 933   3               CSR = in_buf[2];
 934   3      
 935   3               if (cmd == CMD_WRITE_ACK) {
 936   4                  out_buf[0] = CMD_ACK;
 937   4                  out_buf[1] = in_buf[i_in - 1];
 938   4                  send_obuf(2);
 939   4               }
 940   3            }
 941   2         }
 942   1      }
 943          
 944          /*------------------------------------------------------------------*/
 945          
 946          #ifdef UART1_MSCB
              
              static unsigned short xdata last_addr = -1;
              static unsigned char xdata uart1_buf[10];
              
              /*------------------------------------------------------------------*/
              
              void address_node(unsigned short addr)
              {
                 if (addr != last_addr) {
                    uart1_buf[0] = CMD_ADDR_NODE16;
                    uart1_buf[1] = (unsigned char) (addr >> 8);
                    uart1_buf[2] = (unsigned char) (addr & 0xFF);
                    uart1_buf[3] = crc8(uart1_buf, 3);
                    uart1_send(uart1_buf, 4, 1);
                    last_addr = addr;
                 }
              }
              
              /*------------------------------------------------------------------*/
              
              unsigned char ping(unsigned short addr)
              {
                 unsigned char n;
              
                 uart1_buf[0] = CMD_PING16;
                 uart1_buf[1] = (unsigned char) (addr >> 8);
                 uart1_buf[2] = (unsigned char) (addr & 0xFF);
                 uart1_buf[3] = crc8(uart1_buf, 3);
                 uart1_send(uart1_buf, 4, 1);
              
                 n = uart1_receive(uart1_buf, 10);
                 if (n == 0)
                    return 0; // no response
              
                 if (uart1_buf[0] != CMD_ACK)
                    return 0; // invalid response
              
                 return 1; // node resonded
C51 COMPILER V8.10   MSCBMAIN                                                              02/19/2008 13:55:17 PAGE 17  

              }
              
              /*------------------------------------------------------------------*/
              
              void poll_error(unsigned char i)
              {
                 if (i);
                 led_blink(1, 1, 50);
                 last_addr = -1; // force re-adressing of single node
              
                 /* flush input queue of remote device */
                 for (i=0 ; i<10 ; i++)
                    uart1_buf[i] = 0;
                 uart1_send(uart1_buf, 10, 1);
              }
              
              void poll_remote_vars()
              {
              unsigned char i, n;
              
                 for (i=0 ; i<n_variables ; i++)
                    if (variables[i].flags & MSCBF_REMIN) {
                       
                       address_node(variables[i].node_address);
              
                       /* read variable */
                       uart1_buf[0] = CMD_READ + 1;
                       uart1_buf[1] = variables[i].channel;
                       uart1_buf[2] = crc8(uart1_buf, 2);
                       uart1_send(uart1_buf, 3, 0);
              
                       n = uart1_receive(uart1_buf, 100);
              
                       if (n<2) {
                          poll_error(i);
                          continue; // no bytes receive
                       }
              
                       if (uart1_buf[0] != CMD_ACK + n - 2) {
                          poll_error(i);
                          continue; // invalid command received
                       }
              
                       if (variables[i].width != n - 2) {
                          poll_error(i);
                          continue; // variables has wrong length
                       }
              
                       if (uart1_buf[n-1] != crc8(uart1_buf, n-1)) {
                          poll_error(i);
                          continue; // invalid CRC
                       }
              
                       /* all ok, so copy variable */
                       DISABLE_INTERRUPTS;
                       memcpy(variables[i].ud, uart1_buf+1, variables[i].width);
                       ENABLE_INTERRUPTS;
                    }
              
              }
              
              /*------------------------------------------------------------------*/
C51 COMPILER V8.10   MSCBMAIN                                                              02/19/2008 13:55:17 PAGE 18  

              
              void send_remote_var(unsigned char i)
              {
              unsigned char size;
              
                 address_node(variables[i].node_address);
              
                 /* send variable */
                 size = variables[i].width;
                 uart1_buf[0] = CMD_WRITE_NA + size + 1;
                 uart1_buf[1] = variables[i].channel;
                 memcpy(uart1_buf+2, variables[i].ud, size);
                 uart1_buf[2+size] = crc8(uart1_buf, 2+size);
                 uart1_send(uart1_buf, 3+size, 0);
              }
              
              /*------------------------------------------------------------------*/
              
              unsigned long xdata last_poll = 0;
              
              void manage_remote_vars()
              {
                 /* read remote variables once every 10 ms */
                 if (time() > last_poll+10) {
                    poll_remote_vars();
                    last_poll = time();
                 }
              
                 /* send remote variables if changed */
                 if (var_to_send != 0xFF) {
                    send_remote_var(var_to_send);
                    var_to_send = 0xFF;
                 }
              }
              
              #endif // UART1_MSCB
1083          
1084          /*------------------------------------------------------------------*/
1085          
1086          #ifdef LED_0
1087          sbit led_0 = LED_0;
1088          #endif
1089          
1090          #define SEND_BYTE(_b) \
1091             TI0 = 0; \
1092             DELAY_US(INTERCHAR_DELAY); \
1093             SBUF0 = _b; \
1094             while (TI0 == 0);
1095          
1096          #pragma OT(8, SIZE) // 9 would call subroutines in program body -> crash on upgrade
1097          
1098          void upgrade()
1099          {
1100   1         unsigned char cmd, page, crc, j, k;
1101   1         unsigned short i;
1102   1         unsigned char xdata *pw;
1103   1         unsigned char code *pr;
1104   1      
1105   1         if (_flkey != 0xF1)
1106   1            return;
1107   1      
1108   1         /* wait for acknowledge to be sent */
C51 COMPILER V8.10   MSCBMAIN                                                              02/19/2008 13:55:17 PAGE 19  

1109   1         for (i=0 ; i<10000 ; i++) {
1110   2            if (n_out == 0)
1111   2               break;
1112   2            DELAY_US(10);
1113   2         }
1114   1      
1115   1         /* disable all interrupts */
1116   1         EA = 0;
1117   1      #if defined(CPU_C8051F120)
1118   1         SFRPAGE = UART1_PAGE;
1119   1         SCON1 &= ~0x03; // clear pending UART1 interrupts
1120   1      #endif
1121   1      
1122   1         /* disable watchdog */
1123   1      #if defined(CPU_C8051F310) || defined(CPU_C8051F320)
                 PCA0MD = 0x00;
              #else
1126   1         WDTCN = 0xDE;
1127   1         WDTCN = 0xAD;
1128   1      #endif
1129   1      
1130   1         cmd = page = 0;
1131   1      
1132   1         do {
1133   2      
1134   2      receive_cmd:
1135   2      
1136   2      #ifdef CPU_C8051F120
1137   2            SFRPAGE = UART0_PAGE;
1138   2      #endif
1139   2      
1140   2            /* receive command */
1141   2            while (!RI0) {
1142   3               for (i=0 ; !RI0 && i<5000 ; i++)
1143   3                  DELAY_US(10);
1144   3               led_0 = !led_0;
1145   3      #ifdef EXT_WATCHDOG
                       EXT_WATCHDOG_PIN = !EXT_WATCHDOG_PIN;
              #endif
1148   3            }
1149   2      
1150   2            cmd = SBUF0;
1151   2            RI0 = 0;
1152   2      
1153   2      #ifdef EXT_WATCHDOG
                    EXT_WATCHDOG_PIN = !EXT_WATCHDOG_PIN;
              #endif
1156   2      
1157   2            /* cannot use case since it calls the C library */
1158   2      
1159   2            if (cmd == CMD_PING16) {
1160   3      
1161   3               for (i=0 ; !RI0 && i < 5000 ; i++)
1162   3                  DELAY_US(10);
1163   3               if (!RI0) 
1164   3                  goto receive_cmd;
1165   3               page = SBUF0; // LSB
1166   3               RI0 = 0;
1167   3               for (i=0 ; !RI0 && i < 5000 ; i++)
1168   3                  DELAY_US(10);
1169   3               if (!RI0) 
1170   3                  goto receive_cmd;
C51 COMPILER V8.10   MSCBMAIN                                                              02/19/2008 13:55:17 PAGE 20  

1171   3               page = SBUF0; // MSB
1172   3               RI0 = 0;
1173   3               for (i=0 ; !RI0 && i < 5000 ; i++)
1174   3                  DELAY_US(10);
1175   3               if (!RI0) 
1176   3                  goto receive_cmd;
1177   3               page = SBUF0; // CRC
1178   3               RI0 = 0;
1179   3      
1180   3               /* acknowledge ping, independent of own address */
1181   3               RS485_ENABLE = 1;
1182   3               SEND_BYTE(CMD_ACK);
1183   3               DELAY_US(10);
1184   3               RS485_ENABLE = 0;
1185   3      
1186   3            } else if (cmd == CMD_UPGRADE) {
1187   3      
1188   3               for (i=0 ; !RI0 && i < 5000 ; i++)
1189   3                  DELAY_US(10);
1190   3               if (!RI0) 
1191   3                  goto receive_cmd;
1192   3               page = SBUF0; // CRC
1193   3               RI0 = 0;
1194   3      
1195   3               /* acknowledge upgrade */
1196   3               RS485_ENABLE = 1;
1197   3               SEND_BYTE(CMD_ACK+1);
1198   3               SEND_BYTE(1);
1199   3               SEND_BYTE(0); // dummy CRC
1200   3               DELAY_US(10);
1201   3               RS485_ENABLE = 0;
1202   3      
1203   3            } else if (cmd == UCMD_ECHO) {
1204   3      
1205   3               RS485_ENABLE = 1;
1206   3               SEND_BYTE(CMD_ACK);
1207   3               SEND_BYTE(0); // dummy CRC, needed by subm_250
1208   3               DELAY_US(10);
1209   3               RS485_ENABLE = 0;
1210   3      
1211   3            } else if (cmd == UCMD_ERASE) {
1212   3      
1213   3               /* receive page */
1214   3               for (i=0 ; !RI0 && i < 5000 ; i++)
1215   3                  DELAY_US(10);
1216   3               if (!RI0) 
1217   3                  goto receive_cmd;
1218   3      
1219   3               page = SBUF0;
1220   3               RI0 = 0;
1221   3               crc = 0;
1222   3      
1223   3               led_0 = !(page & 1);
1224   3      
1225   3               /* erase page if not page of upgrade() function */
1226   3               if (page*512 < (unsigned int)upgrade && page*512 < EEPROM_OFFSET) {
1227   4      
1228   4      #ifdef CPU_C8051F120
1229   4                  /* for F120, only erase even pages (1024kB page size!) */
1230   4                  if (page & 1)
1231   4                     goto erase_ok;
1232   4      
C51 COMPILER V8.10   MSCBMAIN                                                              02/19/2008 13:55:17 PAGE 21  

1233   4                  SFRPAGE = LEGACY_PAGE;
1234   4      #endif
1235   4      
1236   4      #if defined(CPU_C8051F000)
                          FLSCL = (FLSCL & 0xF0) | 0x08; // set timer for 11.052 MHz clock
              #elif defined (CPU_C8051F020) || defined(CPU_C8051F120)
1239   4                  FLSCL = FLSCL | 1;     // enable flash writes
1240   4      #endif
1241   4                  PSCTL = 0x03;          // allow write and erase
1242   4         
1243   4                  pw = (char xdata *) (512 * page);
1244   4         
1245   4      #if defined(CPU_C8051F310) || defined (CPU_C8051F320)
                          FLKEY = 0xA5;          // write flash key code
                          FLKEY = _flkey;
              #endif
1249   4                  
1250   4                  *pw = 0;
1251   4         
1252   4      #if !defined(CPU_C8051F310) && !defined(CPU_C8051F320)
1253   4                  FLSCL = (FLSCL & 0xF0);
1254   4      #endif
1255   4                  PSCTL = 0x00;
1256   4      
1257   4               } else {
1258   4                  crc = 0xFF;            // return 'protected' flag
1259   4               }
1260   3      
1261   3      #ifdef CPU_C8051F120
1262   3               SFRPAGE = UART0_PAGE;
1263   3      #endif
1264   3      
1265   3      #ifdef CPU_C8051F120
1266   3      erase_ok:
1267   3      #endif
1268   3               /* return acknowledge */
1269   3               RS485_ENABLE = 1;
1270   3               SEND_BYTE(CMD_ACK);
1271   3               SEND_BYTE(crc);
1272   3               DELAY_US(10);
1273   3               RS485_ENABLE = 0;
1274   3      
1275   3            } else if (cmd == UCMD_PROGRAM) {
1276   3      
1277   3               /* receive page */
1278   3               for (i=0 ; !RI0 && i < 5000 ; i++)
1279   3                  DELAY_US(10);
1280   3               if (!RI0) 
1281   3                  goto receive_cmd;
1282   3               page = SBUF0;
1283   3               RI0 = 0;
1284   3      
1285   3               /* receive subpage */
1286   3               for (i=0 ; !RI0 && i < 5000 ; i++)
1287   3                  DELAY_US(10);
1288   3               if (!RI0) 
1289   3                  goto receive_cmd;
1290   3               j = SBUF0;
1291   3               RI0 = 0;
1292   3      
1293   3               led_0 = page & 1;
1294   3      
C51 COMPILER V8.10   MSCBMAIN                                                              02/19/2008 13:55:17 PAGE 22  

1295   3               /* program page if not page of upgrade() function */
1296   3               if (page*512 >= (unsigned int)upgrade || page*512 >= EEPROM_OFFSET)
1297   3                  goto receive_cmd;
1298   3      
1299   3      #ifdef CPU_C8051F120
1300   3               SFRPAGE = LEGACY_PAGE;
1301   3      #endif
1302   3      
1303   3               /* allow write */
1304   3      #if defined(CPU_C8051F000)
                       FLSCL = (FLSCL & 0xF0) | 0x08; // set timer for 11.052 MHz clock
              #elif defined (CPU_C8051F020) || defined(CPU_C8051F120)
1307   3               FLSCL = FLSCL | 1;        // enable flash writes
1308   3      #endif
1309   3               PSCTL = 0x01;             // allow write access
1310   3      
1311   3               pw = (char xdata *) (page*512 + j*32);
1312   3      
1313   3      #ifdef CPU_C8051F120
1314   3               SFRPAGE = UART0_PAGE;
1315   3      #endif
1316   3      
1317   3               /* receive 32 bytes */
1318   3               for (k = 0; k < 32; k++) {
1319   4                  for (i=0 ; !RI0 && i < 5000 ; i++)
1320   4                     DELAY_US(10);
1321   4                  if (!RI0) 
1322   4                     goto receive_cmd;
1323   4      
1324   4      #if defined(CPU_C8051F310) || defined (CPU_C8051F320)
                          FLKEY = 0xA5;          // write flash key code
                          FLKEY = _flkey;
              #endif
1328   4                  /* flash byte */
1329   4                  *pw++ = SBUF0;
1330   4                  RI0 = 0;
1331   4               }
1332   3      
1333   3      #ifdef CPU_C8051F120
1334   3               SFRPAGE = LEGACY_PAGE;
1335   3      #endif
1336   3      
1337   3               /* disable write */
1338   3      #if !defined(CPU_C8051F310) && !defined(CPU_C8051F320)
1339   3               FLSCL = (FLSCL & 0xF0);
1340   3      #endif
1341   3               PSCTL = 0x00;
1342   3      
1343   3      #ifdef CPU_C8051F120
1344   3               SFRPAGE = UART0_PAGE;
1345   3      #endif
1346   3      
1347   3               RS485_ENABLE = 1;
1348   3               SEND_BYTE(CMD_ACK);
1349   3               SEND_BYTE(0);
1350   3               DELAY_US(10);
1351   3               RS485_ENABLE = 0;
1352   3      
1353   3            } else if (cmd == UCMD_VERIFY) {
1354   3      
1355   3               /* receive page */
1356   3               for (i=0 ; !RI0 && i < 5000 ; i++)
C51 COMPILER V8.10   MSCBMAIN                                                              02/19/2008 13:55:17 PAGE 23  

1357   3                  DELAY_US(10);
1358   3               if (!RI0) 
1359   3                  goto receive_cmd;
1360   3      
1361   3               page = SBUF0;
1362   3               RI0 = 0;
1363   3      
1364   3               pr = 512 * page;
1365   3      
1366   3               /* return simplified CRC */
1367   3               for (i = crc = 0; i < 512; i++)
1368   3                  crc += *pr++;
1369   3      
1370   3               /* return acknowledge */
1371   3               RS485_ENABLE = 1;
1372   3               SEND_BYTE(CMD_ACK);
1373   3               SEND_BYTE(crc);
1374   3               DELAY_US(10);
1375   3               RS485_ENABLE = 0;
1376   3      
1377   3            } else if (cmd == UCMD_READ) {
1378   3      
1379   3               /* receive page */
1380   3               for (i=0 ; !RI0 && i < 5000 ; i++)
1381   3                  DELAY_US(10);
1382   3               if (!RI0) 
1383   3                  goto receive_cmd;
1384   3               page = SBUF0;
1385   3               RI0 = 0;
1386   3      
1387   3               /* receive subpage */
1388   3               for (i=0 ; !RI0 && i < 5000 ; i++)
1389   3                  DELAY_US(10);
1390   3               if (!RI0) 
1391   3                  goto receive_cmd;
1392   3               j = SBUF0;
1393   3               RI0 = 0;
1394   3      
1395   3               RS485_ENABLE = 1;
1396   3      
1397   3               SEND_BYTE(CMD_ACK+7);     // send acknowledge, variable data length
1398   3               SEND_BYTE(32);            // send data length
1399   3      
1400   3               pr = (512 * page + 32 * j);
1401   3      
1402   3               /* send 32 bytes */
1403   3               for (k = crc = 0 ; k<32 ; k++) {
1404   4                  SEND_BYTE(*pr);
1405   4                  crc += *pr++;
1406   4               }
1407   3      
1408   3               SEND_BYTE(crc);
1409   3               DELAY_US(10);
1410   3               RS485_ENABLE = 0;
1411   3      
1412   3            } else if (cmd == UCMD_REBOOT) {
1413   3      
1414   3      #ifdef CPU_C8051F120
1415   3               SFRPAGE = LEGACY_PAGE;
1416   3      #endif
1417   3               RSTSRC = 0x10;
1418   3            }
C51 COMPILER V8.10   MSCBMAIN                                                              02/19/2008 13:55:17 PAGE 24  

1419   2      
1420   2         } while (cmd != UCMD_RETURN);
1421   1      
1422   1      
1423   1         _flkey = 0;
1424   1         EA = 1;                      // re-enable interrupts
1425   1      }
1426          
1427          /*------------------------------------------------------------------*\
1428          
1429            Yield should be called periodically by applications with long loops
1430            to insure proper watchdog refresh and other functions
1431          
1432          \*------------------------------------------------------------------*/
1433          
1434          #ifdef HAVE_RTC
              unsigned long xdata rtc_last;   
              #endif
1437          
1438          void yield(void)
1439          {
1440   1         watchdog_refresh(0);
1441   1      
1442   1         /* output RS232 data if present */
1443   1      #if defined(UART1_DEVICE)
                 rs232_output();
              #endif
1446   1      
1447   1         /* blink LED if not configured */
1448   1         if (!configured_addr)
1449   1            led_blink(0, 1, 50);
1450   1      
1451   1         /* blink LED if wrong CPU */
1452   1         if (wrong_cpu)
1453   1            led_blink(0, 1, 30);
1454   1      
1455   1         /* flash EEPROM if asked by interrupt routine, wait 3 sec
1456   1            after reboot (power might not be stable) */
1457   1         if (flash_param && flash_allowed) {
1458   2            led_blink(_cur_sub_addr, 1, 50);
1459   2      
1460   2            flash_param = 0;
1461   2      
1462   2            eeprom_flash(); 
1463   2            configured_addr = 1;
1464   2         }
1465   1      
1466   1         /* flash EEPROM if variables just got initialized */
1467   1         if (!configured_vars && flash_allowed) {
1468   2            _flkey = 0xF1;
1469   2            eeprom_flash();
1470   2            configured_vars = 1;
1471   2         }
1472   1      
1473   1         if (flash_program && flash_allowed) {
1474   2            flash_program = 0;
1475   2      
1476   2      #ifdef HAVE_LCD
                    lcd_clear();
                    lcd_goto(0, 0);
                    puts("    Upgrading"); 
                    lcd_goto(0, 1);
C51 COMPILER V8.10   MSCBMAIN                                                              02/19/2008 13:55:17 PAGE 25  

                    puts("    Firmware...");
              #endif
1483   2      
1484   2            /* go to "bootloader" program */
1485   2            upgrade();
1486   2         }
1487   1      
1488   1      #ifdef HAVE_RTC
                 if (rtc_set) {
                    rtc_write(rtc_bwrite);
                    rtc_set = 0;
                 }
              
                 if (time() > rtc_last+90 || time() < rtc_last) {
                    rtc_last = time();
                    rtc_read(rtc_bread);
                 }
              #endif
1499   1      
1500   1         /* allow flash 3 sec after reboot */
1501   1         if (!flash_allowed && time() > 300)
1502   1            flash_allowed = 1;
1503   1      
1504   1      }
1505          
1506          /*------------------------------------------------------------------*\
1507          
1508            Main loop
1509          
1510          \*------------------------------------------------------------------*/
1511          
1512          void main(void)
1513          {
1514   1         setup();
1515   1      
1516   1         do {
1517   2                    yield();
1518   2            
1519   2      #ifdef UART1_MSCB
                    manage_remote_vars();
              #endif
1522   2            
1523   2            user_loop();
1524   2      
1525   2         } while (1);
1526   1      
1527   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4987    ----
   CONSTANT SIZE    =     11    ----
   XDATA SIZE       =    128    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     23      42
   IDATA SIZE       =     10       4
   BIT SIZE         =      7    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
