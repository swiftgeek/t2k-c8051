C51 COMPILER V8.10   FEB64                                                                 02/19/2008 13:55:18 PAGE 1   


C51 COMPILER V8.10, COMPILATION OF MODULE FEB64
OBJECT MODULE PLACED IN feb64.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE feb64.c BROWSE DEFINE(FEB64,_PCA_INTERNAL_,_SMB_PROTOCOL_,_LTC1669_) DEBUG 
                    -OBJECTEXTEND

line level    source

   1          /********************************************************************\
   2            Name:         feb64.c
   3            Created by:   Bahman Sotoodian                                                        Feb/11/2008
   4          
   5          
   6            Contents:     Application specific (user) part of
   7                          Midas Slow Control Bus protocol
   8                          for FEB64 board
   9                                                   Use "define" for turning functions ON
  10                                                   Possible defines:
  11                                                   _PCA_INTERNAL_ : Q pump 
  12                                                   _PCA9539_      : Bias switches
  13                                                   _ADT7486_      : SST Temperature
  14                                   _AD5301_       : Q pump DAC
  15          
  16            $Id$
  17          
  18          \********************************************************************/
  19          //  need to have FEB64 defined.
  20          
  21          #include <stdio.h>
  22          #include <math.h>
  23          #include "mscbemb.h"
  24          #include "feb64.h"
  25          #ifdef _PCA9539_
              #include "PCA9539_io.h"
              #endif
  28          // #include "ADT7486A_tsensor.h"
  29          // #include "AD5301_dac.h"
  30          #ifdef _LTC1669_
  31          #include "LTC1669_dac.h"
  32          #endif
  33          // #include "AD7718_adc.h"
  34          
  35          /* declare number of sub-addresses to framework */
  36          unsigned char idata _n_sub_addr = 1;
  37          
  38          char code node_name[] = "FEB64";
  39          
  40          /* Charge Pump */
  41          char qpump;
  42          sbit QPUMP = P0 ^ 4;         
  43          
  44          /* Testing the SMBus's Clock */
  45          sbit Clock = P0 ^ 3;
  46          
  47           
  48          struct user_data_type xdata user_data;
  49          
  50          /* User Data structure declaration */
  51          MSCB_INFO_VAR code vars[] = {
  52          
  53             1, UNIT_BYTE,            0, 0,           0, "Control1",     &user_data.control1,    // 0
  54             1, UNIT_BYTE,            0, 0,           0, "Control2",     &user_data.control2,    // 1   
C51 COMPILER V8.10   FEB64                                                                 02/19/2008 13:55:18 PAGE 2   

  55             1, UNIT_BYTE,            0, 0,           0, "Status",       &user_data.status,      // 2
  56             1, UNIT_BYTE,            0, 0,           0, "BiasEN",       &user_data.BiasEN,      // 3
  57             2, UNIT_BYTE,            0, 0,           0, "AsumDac",      &user_data.AsumDac,     // 4
  58             1, UNIT_BYTE,            0, 0,           0, "QpumpDac",     &user_data.QpumpDac,    // 5
  59             1,UNIT_BYTE,             0, 0,           0, "BiasDac1",     &user_data.BiasDac[0],  // 6
  60             1,UNIT_BYTE,             0, 0,           0, "BiasDac2",     &user_data.BiasDac[1],  // 7
  61             1,UNIT_BYTE,             0, 0,           0, "BiasDac3",     &user_data.BiasDac[2],  // 8
  62             1,UNIT_BYTE,             0, 0,           0, "BiasDac4",     &user_data.BiasDac[3],  // 9
  63             1,UNIT_BYTE,             0, 0,           0, "BiasDac5",     &user_data.BiasDac[4],  // 10
  64             1,UNIT_BYTE,             0, 0,           0, "BiasDac6",     &user_data.BiasDac[5],  // 11
  65             1,UNIT_BYTE,             0, 0,           0, "BiasDac7",     &user_data.BiasDac[6],  // 12
  66             1,UNIT_BYTE,             0, 0,           0, "BiasDac8",     &user_data.BiasDac[7],  // 13
  67             1,UNIT_BYTE,             0, 0,           0, "BiasDac9",     &user_data.BiasDac[8],  // 14
  68             1,UNIT_BYTE,             0, 0,           0, "BiasDac10",    &user_data.BiasDac[9],  // 15
  69             1,UNIT_BYTE,             0, 0,           0, "BiasDac11",    &user_data.BiasDac[10], // 16
  70             1,UNIT_BYTE,             0, 0,           0, "BiasDac12",    &user_data.BiasDac[11], // 17
  71             1,UNIT_BYTE,             0, 0,           0, "BiasDac13",    &user_data.BiasDac[12], // 18
  72             1,UNIT_BYTE,             0, 0,           0, "BiasDac14",    &user_data.BiasDac[13], // 19
  73             1,UNIT_BYTE,             0, 0,           0, "BiasDac15",    &user_data.BiasDac[14], // 20
  74             1,UNIT_BYTE,             0, 0,           0, "BiasDac16",    &user_data.BiasDac[15], // 21
  75             1,UNIT_BYTE,             0, 0,           0, "BiasDac17",    &user_data.BiasDac[16], // 22
  76             1,UNIT_BYTE,             0, 0,           0, "BiasDac18",    &user_data.BiasDac[17], // 23
  77             1,UNIT_BYTE,             0, 0,           0, "BiasDac19",    &user_data.BiasDac[18], // 24
  78             1,UNIT_BYTE,             0, 0,           0, "BiasDac20",    &user_data.BiasDac[19], // 25
  79             1,UNIT_BYTE,             0, 0,           0, "BiasDac21",    &user_data.BiasDac[20], // 26
  80             1,UNIT_BYTE,             0, 0,           0, "BiasDac22",    &user_data.BiasDac[21], // 27 
  81             1,UNIT_BYTE,             0, 0,           0, "BiasDac23",    &user_data.BiasDac[22], // 28
  82             1,UNIT_BYTE,             0, 0,           0, "BiasDac24",    &user_data.BiasDac[23], // 29
  83             1,UNIT_BYTE,             0, 0,           0, "BiasDac25",    &user_data.BiasDac[24], // 30
  84             1,UNIT_BYTE,             0, 0,           0, "BiasDac26",    &user_data.BiasDac[25], // 31
  85             1,UNIT_BYTE,             0, 0,           0, "BiasDac27",    &user_data.BiasDac[26], // 32
  86             1,UNIT_BYTE,             0, 0,           0, "BiasDac28",    &user_data.BiasDac[27], // 33
  87             1,UNIT_BYTE,             0, 0,           0, "BiasDac29",    &user_data.BiasDac[28], // 34
  88             1,UNIT_BYTE,             0, 0,           0, "BiasDac30",    &user_data.BiasDac[29], // 35
  89             1,UNIT_BYTE,             0, 0,           0, "BiasDac31",    &user_data.BiasDac[30], // 36
  90             1,UNIT_BYTE,             0, 0,           0, "BiasDac32",    &user_data.BiasDac[31], // 37
  91             1,UNIT_BYTE,             0, 0,           0, "BiasDac33",    &user_data.BiasDac[32], // 38
  92             1,UNIT_BYTE,             0, 0,           0, "BiasDac34",    &user_data.BiasDac[33], // 39
  93             1,UNIT_BYTE,             0, 0,           0, "BiasDac35",    &user_data.BiasDac[34], // 40
  94             1,UNIT_BYTE,             0, 0,           0, "BiasDac36",    &user_data.BiasDac[35], // 41
  95             1,UNIT_BYTE,             0, 0,           0, "BiasDac37",    &user_data.BiasDac[36], // 42
  96             1,UNIT_BYTE,             0, 0,           0, "BiasDac38",    &user_data.BiasDac[37], // 43
  97             1,UNIT_BYTE,             0, 0,           0, "BiasDac39",    &user_data.BiasDac[38], // 44
  98             1,UNIT_BYTE,             0, 0,           0, "BiasDac40",    &user_data.BiasDac[39], // 45
  99             1,UNIT_BYTE,             0, 0,           0, "BiasDac41",    &user_data.BiasDac[40], // 46
 100             1,UNIT_BYTE,             0, 0,           0, "BiasDac42",    &user_data.BiasDac[41], // 47  
 101             1,UNIT_BYTE,             0, 0,           0, "BiasDac43",    &user_data.BiasDac[42], // 48
 102             1,UNIT_BYTE,             0, 0,           0, "BiasDac44",    &user_data.BiasDac[43], // 49
 103             1,UNIT_BYTE,             0, 0,           0, "BiasDac45",    &user_data.BiasDac[44], // 50
 104             1,UNIT_BYTE,             0, 0,           0, "BiasDac46",    &user_data.BiasDac[45], // 51
 105             1,UNIT_BYTE,             0, 0,           0, "BiasDac47",    &user_data.BiasDac[46], // 52
 106             1,UNIT_BYTE,             0, 0,           0, "BiasDac48",    &user_data.BiasDac[47], // 53
 107             1,UNIT_BYTE,             0, 0,           0, "BiasDac49",    &user_data.BiasDac[48], // 54
 108             1,UNIT_BYTE,             0, 0,           0, "BiasDac50",    &user_data.BiasDac[49], // 55
 109             1,UNIT_BYTE,             0, 0,           0, "BiasDac51",    &user_data.BiasDac[50], // 56
 110             1,UNIT_BYTE,             0, 0,           0, "BiasDac52",    &user_data.BiasDac[51], // 57
 111             1,UNIT_BYTE,             0, 0,           0, "BiasDac53",    &user_data.BiasDac[52], // 58
 112             1,UNIT_BYTE,             0, 0,           0, "BiasDac54",    &user_data.BiasDac[53], // 59
 113             1,UNIT_BYTE,             0, 0,           0, "BiasDac55",    &user_data.BiasDac[54], // 60
 114             1,UNIT_BYTE,             0, 0,           0, "BiasDac56",    &user_data.BiasDac[55], // 61
 115             1,UNIT_BYTE,             0, 0,           0, "BiasDac57",    &user_data.BiasDac[56], // 62
 116             1,UNIT_BYTE,             0, 0,           0, "BiasDac58",    &user_data.BiasDac[57], // 63
C51 COMPILER V8.10   FEB64                                                                 02/19/2008 13:55:18 PAGE 3   

 117             1,UNIT_BYTE,             0, 0,           0, "BiasDac59",    &user_data.BiasDac[58], // 64
 118             1,UNIT_BYTE,             0, 0,           0, "BiasDac60",    &user_data.BiasDac[59], // 65
 119             1,UNIT_BYTE,             0, 0,           0, "BiasDac61",    &user_data.BiasDac[60], // 66
 120             1,UNIT_BYTE,             0, 0,           0, "BiasDac62",    &user_data.BiasDac[61], // 67
 121             1,UNIT_BYTE,             0, 0,           0, "BiasDac63",    &user_data.BiasDac[62], // 68
 122             1,UNIT_BYTE,             0, 0,           0, "BiasDac64",    &user_data.BiasDac[63], // 69
 123             
 124             
 125             4, UNIT_VOLT,            0, 0, MSCBF_FLOAT, "BiasVGbl",   &user_data.BiasVGbl,    // 70 
 126             4, UNIT_AMPERE, PRFX_MILLI, 0, MSCBF_FLOAT, "BiasIGbl",   &user_data.BiasIGbl,    // 71  
 127             4, UNIT_VOLT,            0, 0, MSCBF_FLOAT, "pAVMon",     &user_data.pAVMon,          // 72   
 128             4, UNIT_AMPERE, PRFX_MILLI, 0, MSCBF_FLOAT, "pAIMon",     &user_data.pAIMon,          // 73
 129             4, UNIT_VOLT,            0, 0, MSCBF_FLOAT, "pDVMon",     &user_data.pDVMon,          // 74 
 130             4, UNIT_AMPERE, PRFX_MILLI, 0, MSCBF_FLOAT, "pDIMon",     &user_data.pDIMon,          // 75
 131             4, UNIT_VOLT,            0, 0, MSCBF_FLOAT, "nAVMon",     &user_data.nAVMon,          // 76
 132             4, UNIT_AMPERE, PRFX_MILLI, 0, MSCBF_FLOAT, "nAIMon",     &user_data.nAIMon,          // 77
 133             
 134             4, UNIT_BYTE,                        0, 0,                   0,  "BiasVADC",  &user_data.BiasVADC,    // 78
 135             4, UNIT_BYTE,                        0, 0,                   0,  "BiasIADC",  &user_data.BiasIADC,    // 79 
 136             4, UNIT_BYTE,                        0, 0,                   0,  "pAVADC",    &user_data.pAVADC,      // 80
 137             4, UNIT_BYTE,                        0, 0,                   0,  "pAIADC",    &user_data.pAIADC,      // 81 
 138             4, UNIT_BYTE,                        0, 0,                   0,  "pDVADC",    &user_data.pDVADC,      // 82
 139             4, UNIT_BYTE,                        0, 0,                   0,  "pDIADC",    &user_data.pDIADC,      // 83
 140             4, UNIT_BYTE,                        0, 0,                   0,  "nAVADC",    &user_data.nAVADC,      // 84 
 141             4, UNIT_BYTE,                        0, 0,                   0,  "nAIADC",    &user_data.nAIADC,      // 85 
 142             
 143             4, UNIT_CELSIUS,         0, 0, MSCBF_FLOAT, "Temp1",       &user_data.Temp[0],    // 86
 144             4, UNIT_CELSIUS,         0, 0, MSCBF_FLOAT, "Temp2",       &user_data.Temp[1],    // 87  
 145             4, UNIT_CELSIUS,         0, 0, MSCBF_FLOAT, "Temp3",       &user_data.Temp[2],    // 88  
 146             4, UNIT_CELSIUS,         0, 0, MSCBF_FLOAT, "Temp4",       &user_data.Temp[3],    // 89  
 147             4, UNIT_CELSIUS,         0, 0, MSCBF_FLOAT, "Temp5",       &user_data.Temp[4],    // 90  
 148             4, UNIT_CELSIUS,         0, 0, MSCBF_FLOAT, "Temp6",       &user_data.Temp[5],    // 91  
 149             4, UNIT_CELSIUS,         0, 0, MSCBF_FLOAT, "Temp7",       &user_data.Temp[6],    // 92  
 150             4, UNIT_CELSIUS,         0, 0, MSCBF_FLOAT, "Temp8",       &user_data.Temp[7],    // 93  
 151          
 152             4, UNIT_VOLT,            0, 0, MSCBF_FLOAT, "BiasVgrp1",   &user_data.BiasVgrp[0], // 94 
 153             4, UNIT_VOLT,            0, 0, MSCBF_FLOAT, "BiasVgrp2",   &user_data.BiasVgrp[1], // 95
 154             4, UNIT_VOLT,            0, 0, MSCBF_FLOAT, "BiasVgrp3",   &user_data.BiasVgrp[2], // 96
 155             4, UNIT_VOLT,            0, 0, MSCBF_FLOAT, "BiasVgrp4",   &user_data.BiasVgrp[3], // 97
 156             4, UNIT_VOLT,            0, 0, MSCBF_FLOAT, "BiasVgrp5",   &user_data.BiasVgrp[4], // 98
 157             4, UNIT_VOLT,            0, 0, MSCBF_FLOAT, "BiasVgrp6",   &user_data.BiasVgrp[5], // 99
 158             4, UNIT_VOLT,            0, 0, MSCBF_FLOAT, "BiasVgrp7",   &user_data.BiasVgrp[6], // 100
 159             4, UNIT_VOLT,            0, 0, MSCBF_FLOAT, "BiasVgrp8",   &user_data.BiasVgrp[7], // 101
 160             
 161          
 162             4, UNIT_AMPERE, PRFX_MILLI, 0, MSCBF_FLOAT, "BiasIgrp1",   &user_data.BiasIgrp[0], // 102
 163             4, UNIT_AMPERE, PRFX_MILLI, 0, MSCBF_FLOAT, "BiasIgrp2",   &user_data.BiasIgrp[1], // 103
 164             4, UNIT_AMPERE, PRFX_MILLI, 0, MSCBF_FLOAT, "BiasIgrp3",   &user_data.BiasIgrp[2], // 104
 165             4, UNIT_AMPERE, PRFX_MILLI, 0, MSCBF_FLOAT, "BiasIgrp4",   &user_data.BiasIgrp[3], // 105
 166             4, UNIT_AMPERE, PRFX_MILLI, 0, MSCBF_FLOAT, "BiasIgrp5",   &user_data.BiasIgrp[4], // 106
 167             4, UNIT_AMPERE, PRFX_MILLI, 0, MSCBF_FLOAT, "BiasIgrp6",   &user_data.BiasIgrp[5], // 107
 168             4, UNIT_AMPERE, PRFX_MILLI, 0, MSCBF_FLOAT, "BiasIgrp7",   &user_data.BiasIgrp[6], // 108
 169             4, UNIT_AMPERE, PRFX_MILLI, 0, MSCBF_FLOAT, "BiasIgrp8",   &user_data.BiasIgrp[7], // 109
 170                
 171             4, UNIT_BYTE,                        0, 0,                   0,  "BiasVadc1",  &user_data.BiasVadc[0], // 110
 172             4, UNIT_BYTE,                        0, 0,                   0,  "BiasVadc2",  &user_data.BiasVadc[1], // 111
 173             4, UNIT_BYTE,                        0, 0,                   0,  "BiasVadc3",  &user_data.BiasVadc[2], // 112
 174             4, UNIT_BYTE,                        0, 0,                   0,  "BiasVadc4",  &user_data.BiasVadc[3], // 113
 175             4, UNIT_BYTE,                        0, 0,                   0,  "BiasVadc5",  &user_data.BiasVadc[4], // 114
 176             4, UNIT_BYTE,                        0, 0,                   0,  "BiasVadc6",  &user_data.BiasVadc[5], // 115
 177             4, UNIT_BYTE,                        0, 0,                   0,  "BiasVadc7",  &user_data.BiasVadc[6], // 116
 178             4, UNIT_BYTE,                        0, 0,                   0,  "BiasVadc8",  &user_data.BiasVadc[7], // 117
C51 COMPILER V8.10   FEB64                                                                 02/19/2008 13:55:18 PAGE 4   

 179          
 180             4, UNIT_BYTE,                        0, 0,                   0,  "BiasIadc1",  &user_data.BiasIadc[0], // 118
 181             4, UNIT_BYTE,                        0, 0,                   0,  "BiasIadc2",  &user_data.BiasIadc[1], // 119
 182             4, UNIT_BYTE,                        0, 0,                   0,  "BiasIadc3",  &user_data.BiasIadc[2], // 120
 183             4, UNIT_BYTE,                        0, 0,                   0,  "BiasIadc4",  &user_data.BiasIadc[3], // 121
 184             4, UNIT_BYTE,                        0, 0,                   0,  "BiasIadc5",  &user_data.BiasIadc[4], // 122
 185             4, UNIT_BYTE,                        0, 0,                   0,  "BiasIadc6",  &user_data.BiasIadc[5], // 123
 186             4, UNIT_BYTE,                        0, 0,                   0,  "BiasIadc7",  &user_data.BiasIadc[6], // 124
 187             4, UNIT_BYTE,                        0, 0,                   0,  "BiasIadc8",  &user_data.BiasIadc[7], // 125
 188             0
 189          };
 190          
 191          
 192          MSCB_INFO_VAR *variables = vars;
 193          
 194          /********************************************************************\
 195          
 196            Application specific init and inout/output routines
 197          
 198          \********************************************************************/
 199          
 200          /*---- User init function ------------------------------------------*/
 201          
 202          extern SYS_INFO sys_info;
 203          //unsigned char ADT7486A_addrArray[] = {ADT7486A_ADDR_ARRAY};
 204          
 205          void user_init(unsigned char init)
 206          {
 207   1      
 208   1      //   /* all outputs are set to open drain on pin1 and pin2 */
 209   1         SFRPAGE  = CONFIG_PAGE;
 210   1         P1MDOUT = 0x00;
 211   1         P2MDOUT = 0x00;
 212   1         
 213   1              
 214   1              init = 1;
 215   1         /* default settings, set only when EEPROM is being erased and written */
 216   1      //      if(init)
 217   1      //      {
 218   1      //              user_data.control = 0x7D; //Turn on the charge pump 
 219   1      //              user_data.status   = 0x00;
 220   1      //              user_data.biasEn   = 0xFF;
 221   1      //              user_data.dac_asumThreshold   = 0x80;
 222   1      //              user_data.dac_chPump   = 0x00; //set to lowest scale, just to be safe
 223   1      //              user_data.biasDac1   = 0xFF;
 224   1      //              user_data.biasDac2   = 0xFF;
 225   1      //              user_data.biasDac3   = 0xFF;
 226   1      //              user_data.biasDac4   = 0xFF;
 227   1      //              user_data.biasDac5   = 0xFF;
 228   1      //              user_data.biasDac6   = 0xFF;
 229   1      //              user_data.biasDac7   = 0xFF;
 230   1      //              user_data.biasDac8   = 0xFF;            
 231   1      //              sys_info.group_addr = 400;
 232   1      //              sys_info.node_addr = 0xFF00;
 233   1      //      }   
 234   1      
 235   1              /* Cross Bar Settings */
 236   1      
 237   1              /* Comparator 0 Settings */
 238   1      //BS    CPT0CN = 0xC0; //Enable Comparator0 (functional, the one above is only for CrossBar)
 239   1      
 240   1      //      CPT0MX = 0x22; //Comparator0 MUX selection
C51 COMPILER V8.10   FEB64                                                                 02/19/2008 13:55:18 PAGE 5   

 241   1                      //Negative input is set to P2 ^ 1, and Positive input is set to P2 ^ 0
 242   1                      // (P2 ^ 0 is the SST1, so we want to compare SST1 with the threshold voltage
 243   1                      //of !~0.8V on P2 ^ 1
 244   1      //BS    CPT0MD = 0x02; //Comparator0 Mode Selection
 245   1                      //Use default, adequate TYP (CP0 Response Time, no edge triggered interrupt)
 246   1      
 247   1              //Set P2 ^ 1 to Open-Drain and Analog Input so that it accepts the ~650mV set by voltage divider
 248   1      //BS    P2MDOUT &= 0xFD;
 249   1      //      P2MDIN &= 0xFD;
 250   1      
 251   1         /* set-up / initialize circuit components (order is important)*/
 252   1      
 253   1      #ifdef _ADT7486_
                 ADT7486A_Init(); //Temperature measurements related initialization
              #endif
 256   1      
 257   1      
 258   1      //      AD7718_Init(); //ADC initialization              
 259   1      
 260   1      #ifdef _PCA_INTERNAL_
 261   1              pca_operation(Q_PUMP_INIT); //Charge Pump initialization (crossbar settings)
 262   1          pca_operation(Q_PUMP_ON);   //Initially turn it on  
 263   1      #endif
 264   1      
 265   1      #ifdef _LTC1669_        
 266   1              LTC1669_Init(); //I2C DAC initialization (D_CH_PUMP)
 267   1              user_data.control1 = 0x41; //Set the control bit for Qpump and the Qpump threashold enable bit
 268   1      #endif
 269   1      
 270   1      #ifdef _PCA9539_
                      PCA9539_Init(); //PCA General I/O (Bais Enables and Backplane Addr) initialization      
              #endif
 273   1      
 274   1      //#ifdef _AD5301_
 275   1      //      AD5301_Init();  
 276   1      //      user_data.control = 0x81;
 277   1      //#endif
 278   1      }
 279          
 280          #ifdef _PCA_INTERNAL_
 281          /*---- PCA initilalization -----------------------------------------*/
 282          void pca_operation(unsigned char mode)
 283          {
 284   1              
 285   1              if (mode == Q_PUMP_INIT) 
 286   1              {
 287   2                      /* PCA setup for Frequency Output Mode on CEX0 */
 288   2                      SFRPAGE  = CONFIG_PAGE;
 289   2                      P0MDOUT |= 0x10; // Add pin 4 (CHG_PMP_CLK) to PushPull
 290   2                      XBR0     = 0x0D; // Route SMB (SDA and SCL); Rout UART (TX and RX);and Rout CEX0(CHG_PMP_CLK) to their p
             -ins 
 291   2              XBR1    |= 0x80;
 292   2                      XBR2     = 0x40; // Enable Xbar
 293   2      
 294   2                      SFRPAGE  = LEGACY_PAGE;
 295   2                      PCA0MD   = 0x02;  // Sysclk (default CKCON [2MHz])
 296   2                      PCA0CPL0 = 0x00;
 297   2                      PCA0CPM0 = 0x46; // ECM, TOG, PWM
 298   2                      PCA0CPH0 = 0 ; // 6 (for ~2MHz)                
 299   2                      PCA0CN   = 0x40; // Enable PCA Run Control 
 300   2              } 
 301   1              else if (mode == Q_PUMP_OFF) 
C51 COMPILER V8.10   FEB64                                                                 02/19/2008 13:55:18 PAGE 6   

 302   1              {
 303   2                      SFRPAGE  = LEGACY_PAGE;
 304   2                      PCA0CN   = 0x00 ;   //Turn off the PCA counter
 305   2                      //XBR0 = (XBR0 & 0xC7) | 0x00; // Turn off Frequency Output Mode (All PCA0 I/O unavailable at port pins)
 306   2              } 
 307   1              else if (mode == Q_PUMP_ON)
 308   1              {
 309   2                      SFRPAGE  = LEGACY_PAGE;
 310   2                      PCA0CN   = 0x40 ;   //Turn on the PCA counter
 311   2                      //XBR0 = (XBR0 & 0xC7) | 0x08; // Turn on Frequency Output Mode
 312   2              }
 313   1      }
 314          #endif // _PCA_INTERNAL_
 315          
 316          /*---- User write function -----------------------------------------*/
 317          
 318          #pragma NOAREGS
 319          
 320          void user_write(unsigned char index) reentrant
 321          {
 322   1         unsigned char command, mask;
 323   1      
 324   1         // In case of you changing common control bit (ex. EXT/IN switch bit)
 325   1         // the change should be distributed to other channels.
 326   1         if (index == 0) {
 327   2             // preserve common command bits for all channels
 328   2             command = user_data.control1;
 329   2             mask    = CONTROL_QPUMP; // common bits
 330   2      
 331   2             user_data.control1 &= ~mask;
 332   2             user_data.control1 |= (command & mask);
 333   2         }
 334   1      }
 335          
 336          /*---- User read function ------------------------------------------*/
 337          
 338          unsigned char user_read(unsigned char index)
 339          {
 340   1         if (index);
 341   1         return 0;
 342   1      }
 343          
 344          /*---- User function called via CMD_USER command -------------------*/
 345          
 346          unsigned char user_func(unsigned char *data_in, unsigned char *data_out)
 347          {
 348   1         /* echo input data */
 349   1         data_out[0] = data_in[0];
 350   1         data_out[1] = data_in[1];
 351   1         return 2;
 352   1      }
 353          
 354          
 355          /*---- User loop function ------------------------------------------*/
 356          void user_loop(void)
 357          {
 358   1              signed char chNum = 0;
 359   1              watchdog_refresh(0);
 360   1              
 361   1              if(user_data.control1 & CONTROL_QPUMP)
 362   1              {
 363   2                      pca_operation(Q_PUMP_ON);
C51 COMPILER V8.10   FEB64                                                                 02/19/2008 13:55:18 PAGE 7   

 364   2              }
 365   1              else
 366   1              {
 367   2                      pca_operation(Q_PUMP_OFF);
 368   2              }
 369   1          
 370   1              //Update the Charge Pump Threshold voltage
 371   1              if(user_data.control1 & CONTROL_D_CHPUMP)
 372   1              {
 373   2                      #ifdef _LTC1669_        
 374   2                      LTC1669_Cmd(ADDR_LTC1669, (user_data.QpumpDac >> 4), (user_data.QpumpDac << 4), LTC1669_WRITE);
 375   2                      #endif 
 376   2              }
 377   1              
 378   1      
 379   1              //Added to turn on and off all the channels     
 380   1              if( user_data.control1 & CONTROL_CHANNEL )
 381   1              {
 382   2              chNum = 0; 
 383   2      
 384   2                      #ifdef _PCA9539_
                              PCA9539_Cmd(Bias_ALL_LOW);      
                              #endif
 387   2              }
 388   1      //      yield();
 389   1      }
 390          
 391          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    245    ----
   CONSTANT SIZE    =   2165    ----
   XDATA SIZE       =    295    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4       8
   IDATA SIZE       =      1    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
