C51 COMPILER V8.10   MSCBUTIL                                                              02/19/2008 13:55:17 PAGE 1   


C51 COMPILER V8.10, COMPILATION OF MODULE MSCBUTIL
OBJECT MODULE PLACED IN mscbutil.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE mscbutil.c BROWSE DEFINE(FEB64,_PCA_INTERNAL_,_SMB_PROTOCOL_,_LTC1669_) DEB
                    -UG OBJECTEXTEND

line level    source

   1          /********************************************************************\
   2          
   3            Name:         mscbutil.c
   4            Created by:   Stefan Ritt
   5          
   6            Contents:     Various utility functions for MSCB protocol
   7          
   8            $Id: mscbutil.c 38 2008-01-29 23:19:00Z fgddaq $
   9          
  10          \********************************************************************/
  11          
  12          #include <intrins.h>
  13          #include <string.h>
  14          #include <stdio.h>
  15          #include "mscbemb.h"
  16          
  17          #ifdef HAVE_EEPROM
  18          
  19          extern SYS_INFO sys_info;               // for eeprom functions
  20          extern MSCB_INFO_VAR *variables;
  21          
  22          #endif
  23          
  24          extern unsigned char idata _n_sub_addr, _var_size, _flkey;
  25          
  26          #pragma NOAREGS                 // all functions can be called from interrupt routine!
  27          
  28          /*------------------------------------------------------------------*/
  29          
  30          unsigned char code crc8_data[] = {
  31             0x00, 0x5e, 0xbc, 0xe2, 0x61, 0x3f, 0xdd, 0x83,
  32             0xc2, 0x9c, 0x7e, 0x20, 0xa3, 0xfd, 0x1f, 0x41,
  33             0x9d, 0xc3, 0x21, 0x7f, 0xfc, 0xa2, 0x40, 0x1e,
  34             0x5f, 0x01, 0xe3, 0xbd, 0x3e, 0x60, 0x82, 0xdc,
  35             0x23, 0x7d, 0x9f, 0xc1, 0x42, 0x1c, 0xfe, 0xa0,
  36             0xe1, 0xbf, 0x5d, 0x03, 0x80, 0xde, 0x3c, 0x62,
  37             0xbe, 0xe0, 0x02, 0x5c, 0xdf, 0x81, 0x63, 0x3d,
  38             0x7c, 0x22, 0xc0, 0x9e, 0x1d, 0x43, 0xa1, 0xff,
  39             0x46, 0x18, 0xfa, 0xa4, 0x27, 0x79, 0x9b, 0xc5,
  40             0x84, 0xda, 0x38, 0x66, 0xe5, 0xbb, 0x59, 0x07,
  41             0xdb, 0x85, 0x67, 0x39, 0xba, 0xe4, 0x06, 0x58,
  42             0x19, 0x47, 0xa5, 0xfb, 0x78, 0x26, 0xc4, 0x9a,
  43             0x65, 0x3b, 0xd9, 0x87, 0x04, 0x5a, 0xb8, 0xe6,
  44             0xa7, 0xf9, 0x1b, 0x45, 0xc6, 0x98, 0x7a, 0x24,
  45             0xf8, 0xa6, 0x44, 0x1a, 0x99, 0xc7, 0x25, 0x7b,
  46             0x3a, 0x64, 0x86, 0xd8, 0x5b, 0x05, 0xe7, 0xb9,
  47             0x8c, 0xd2, 0x30, 0x6e, 0xed, 0xb3, 0x51, 0x0f,
  48             0x4e, 0x10, 0xf2, 0xac, 0x2f, 0x71, 0x93, 0xcd,
  49             0x11, 0x4f, 0xad, 0xf3, 0x70, 0x2e, 0xcc, 0x92,
  50             0xd3, 0x8d, 0x6f, 0x31, 0xb2, 0xec, 0x0e, 0x50,
  51             0xaf, 0xf1, 0x13, 0x4d, 0xce, 0x90, 0x72, 0x2c,
  52             0x6d, 0x33, 0xd1, 0x8f, 0x0c, 0x52, 0xb0, 0xee,
  53             0x32, 0x6c, 0x8e, 0xd0, 0x53, 0x0d, 0xef, 0xb1,
  54             0xf0, 0xae, 0x4c, 0x12, 0x91, 0xcf, 0x2d, 0x73,
C51 COMPILER V8.10   MSCBUTIL                                                              02/19/2008 13:55:17 PAGE 2   

  55             0xca, 0x94, 0x76, 0x28, 0xab, 0xf5, 0x17, 0x49,
  56             0x08, 0x56, 0xb4, 0xea, 0x69, 0x37, 0xd5, 0x8b,
  57             0x57, 0x09, 0xeb, 0xb5, 0x36, 0x68, 0x8a, 0xd4,
  58             0x95, 0xcb, 0x29, 0x77, 0xf4, 0xaa, 0x48, 0x16,
  59             0xe9, 0xb7, 0x55, 0x0b, 0x88, 0xd6, 0x34, 0x6a,
  60             0x2b, 0x75, 0x97, 0xc9, 0x4a, 0x14, 0xf6, 0xa8,
  61             0x74, 0x2a, 0xc8, 0x96, 0x15, 0x4b, 0xa9, 0xf7,
  62             0xb6, 0xe8, 0x0a, 0x54, 0xd7, 0x89, 0x6b, 0x35,
  63          };
  64          
  65          unsigned char crc8(unsigned char *buffer, int len) reentrant
  66          /********************************************************************\
  67          
  68            Routine: crc8
  69          
  70            Purpose: Calculate 8-bit cyclic redundancy checksum for a full
  71                     buffer
  72          
  73            Input:
  74              unsigned char *data     data buffer
  75              int len                 data length in bytes
  76          
  77          
  78            Function value:
  79              unsighend char          CRC-8 code
  80          
  81          \********************************************************************/
  82          {
  83   1         int i;
  84   1         unsigned char crc8_code, index;
  85   1      
  86   1         crc8_code = 0;
  87   1         for (i = 0; i < len; i++) {
  88   2            index = buffer[i] ^ crc8_code;
  89   2            crc8_code = crc8_data[index];
  90   2         }
  91   1      
  92   1         return crc8_code;
  93   1      }
  94          
  95          unsigned char crc8_add(unsigned char crc, unsigned int c)
  96          /********************************************************************\
  97          
  98            Routine: crc8_add
  99          
 100            Purpose: Single calculation for 8-bit cyclic redundancy checksum
 101          
 102            Input:
 103              unsigned char crc       running crc
 104              unsigned char c         new character
 105          
 106          
 107            Function value:
 108              unsighend char          CRC-8 code
 109          
 110          \********************************************************************/
 111          {
 112   1         unsigned char index;
 113   1      
 114   1         index = c ^ crc;
 115   1         return crc8_data[index];
 116   1      }
C51 COMPILER V8.10   MSCBUTIL                                                              02/19/2008 13:55:17 PAGE 3   

 117          
 118          /*------------------------------------------------------------------*/
 119          
 120          //####################################################################
 121          #if defined(UART1_DEVICE) // user-level device communication via UART1
              
              bit ti1_shadow = 1;
              
              char xdata rbuf[2048];
              char xdata sbuf[1024];
              
              unsigned char xdata * xdata rbuf_rp = rbuf;
              unsigned char xdata * xdata rbuf_wp = rbuf;
              unsigned char xdata * xdata sbuf_rp = sbuf;
              unsigned char xdata * xdata sbuf_wp = sbuf;
              
              /*---- UART1 handling ----------------------------------------------*/
              
              void serial_int1(void) interrupt 20
              {
                 if (SCON1 & 0x02) {          // TI1
              
              #if defined(SCS_220) || defined(SCS_1000) || defined(SCS_1001) || defined(SCS_2000)
                    if (sbuf_wp == sbuf_rp)
                       RS485_SEC_ENABLE = 0;
              #endif
              
                    /* character has been transferred */
                    SCON1 &= ~0x02;           // clear TI flag
                    ti1_shadow = 1;
                 }
              
                 if (SCON1 & 0x01) {          // RI1
                    /* check for buffer overflow */
                    if (rbuf_wp + 1 == rbuf_rp) {
                       SCON1 &= ~0x01;        // clear RI flag
                       return;
                    }
              
                    /* character has been received */
                    *rbuf_wp++ = SBUF1;
                    if (rbuf_wp == rbuf + sizeof(rbuf))
                       rbuf_wp = rbuf;
              
                    SCON1 &= ~0x01;           // clear RI flag
              
                    led_blink(1, 1, 100);
                 }
              }
              
              /*------------------------------------------------------------------*/
              
              void rs232_output(void)
              /* check RS232 output buffer to send data */
              {
                 if (sbuf_wp != sbuf_rp && ti1_shadow == 1) {
                    ti1_shadow = 0;
              #if defined(SCS_220) || defined(SCS_1000) || defined(SCS_1001) || defined(SCS_2000)
                    RS485_SEC_ENABLE = 1;
              #endif
              
              #ifdef CPU_C8051F120
C51 COMPILER V8.10   MSCBUTIL                                                              02/19/2008 13:55:17 PAGE 4   

                    SFRPAGE = UART1_PAGE;
              #endif
              
                    SBUF1 = *sbuf_rp++;
                    if (sbuf_rp == sbuf + sizeof(sbuf))
                       sbuf_rp = sbuf;
                 }
              }
              
              /*------------------------------------------------------------------*/
              
              char getchar(void)
              {
                 char c;
              
                 do {
                    if (rbuf_wp != rbuf_rp) {
                       c = *rbuf_rp++;
                       if (rbuf_rp == rbuf + sizeof(rbuf))
                          rbuf_rp = rbuf;
              
                       if (c == '\r')         /* make gets() happy */
                          return '\n';
              
                       return c;
                    }
                    yield();
                 } while (1);
              }
              
              /*------------------------------------------------------------------*/
              
              char getchar_nowait(void)
              {
                 char c;
              
                 if (rbuf_wp != rbuf_rp) {
                    c = *rbuf_rp++;
                    if (rbuf_rp == rbuf + sizeof(rbuf))
                       rbuf_rp = rbuf;
              
                    return c;
                 }
                 return -1;
              }
              
              /*------------------------------------------------------------------*/
              
              unsigned char gets_wait(char *str, unsigned char size, unsigned char timeout)
              {
                 unsigned long start;
                 unsigned char i;
                 char c;
              
                 start = time();
                 i = 0;
                 do {
                    c = getchar_nowait();
                    if (c != -1 && c != '\n') {
                       if (c == '\r') {
                          str[i] = 0;
                          return i;
C51 COMPILER V8.10   MSCBUTIL                                                              02/19/2008 13:55:17 PAGE 5   

                       }
                       str[i++] = c;
                       if (i == size)
                          return i;
                    }
              
                    yield();
                 } while (time() < start + timeout);
              
                 return 0;
              }
              
              /*------------------------------------------------------------------*/
              
              #ifdef HAVE_LCD // putchar is already used for LCD
              
              char putchar1(char c)
              {
                 /* check if buffer overflow */
                 if (sbuf_wp + 1 == sbuf_rp)
                    return c;
              
                 *sbuf_wp++ = c;
                 if (sbuf_wp == sbuf + sizeof(sbuf))
                    sbuf_wp = sbuf;
              
                 return c;
              }
              
              #else // HAVE_LCD
              
              char putchar(char c)
              {
                 /* check if buffer overflow */
                 if (sbuf_wp + 1 == sbuf_rp)
                    return c;
              
                 *sbuf_wp++ = c;
                 if (sbuf_wp == sbuf + sizeof(sbuf))
                    sbuf_wp = sbuf;
              
                 return c;
              }
              
              #endif // HAVE_LCD
              
              /*------------------------------------------------------------------*/
              
              void flush(void)
              {
                 while (sbuf_wp != sbuf_rp)
                    rs232_output();
              }
              
              /*------------------------------------------------------------------*/
              
              void uart1_init_buffer()
              {
                 rbuf_rp = rbuf_wp = rbuf;
                 sbuf_rp = sbuf_wp = sbuf;
                 memset(rbuf, 0, sizeof(rbuf));
                 memset(sbuf, 0, sizeof(sbuf));
C51 COMPILER V8.10   MSCBUTIL                                                              02/19/2008 13:55:17 PAGE 6   

              
                 ti1_shadow = 1;
              }
              
              /*------------------------------------------------------------------*/
              
              #endif // UART1_DEVICE ###############################################
 310          
 311          #if defined(UART1_MSCB) // UART1 connected as master to MSCB slave bus
              
              bit ti1_shadow = 1;
              unsigned char n_recv;
              
              char xdata rbuf[64];
              
              /*---- UART1 handling ----------------------------------------------*/
              
              void serial_int1(void) interrupt 20 
              {
                 if (SCON1 & 0x02) {          // TI1
                    /* character has been transferred */
                    SCON1 &= ~0x02;           // clear TI flag
                    ti1_shadow = 1;
                 }
              
                 if (SCON1 & 0x01) {          // RI1
                    /* check for buffer overflow */
                    if (n_recv + 1 == sizeof(rbuf)) {
                       SCON1 &= ~0x01;        // clear RI flag
                       return;
                    }
              
                    /* character has been received */
                    rbuf[n_recv++] = SBUF1;
                    SCON1 &= ~0x01;           // clear RI flag
                 }
              }
              
              /*------------------------------------------------------------------*/
              
              unsigned char uart1_send(char *buffer, int size, unsigned char bit9)
              {
              unsigned char i;
              
                 /* empty receive buffer */
                 n_recv = 0;
              
                 SFRPAGE = UART1_PAGE;
              
                 RS485_SEC_ENABLE = 1;
                 TB81 = bit9;
              
                 for (i=0 ; i<size ; i++) {
              
                    ti1_shadow = 0;
              
                    DELAY_US(INTERCHAR_DELAY);
              
                    if (i == size-1) {
                      
                       /* interrupt between last send and enable=0 could cause bus collision */
                       ES0 = 0;
C51 COMPILER V8.10   MSCBUTIL                                                              02/19/2008 13:55:17 PAGE 7   

              
                       SBUF1 = *buffer++;
                       while (ti1_shadow == 0);
                       
                       RS485_SEC_ENABLE = 0;
              
                       ES0 = 1;
              
                    } else {
              
                       SBUF1 = *buffer++;
                       while (ti1_shadow == 0);
              
                    }
              
                    watchdog_refresh(1);
                 }
                 RS485_SEC_ENABLE = 0;
              
                 return size;
              }
              
              /*------------------------------------------------------------------*/
              
              unsigned char uart1_receive(char *buffer, int size)
              {
              unsigned char len;
              long start_time;
              
                 start_time = time();
                 len = 0;
                 do {
              
                    if (time() - start_time > 1) // timeout after 20ms
                       return 0;
              
                    if (n_recv > 0) {
              
                       /* response to ping */
                       if (rbuf[0] == CMD_ACK)
                          return 1;
              
                       /* response to CMD_READ */
                       if ((rbuf[0] & 0xF8) != CMD_ACK)
                          return 0;
              
                       len = (rbuf[0] & 0x07) + 2;
              
                       if (n_recv == len) {
                          if (n_recv > size)
                             memcpy(buffer, rbuf, size);
                          else
                             memcpy(buffer, rbuf, n_recv);
                          return len;
                       }
                    }
              
                    watchdog_refresh(1);
              
                 } while (1);
              
                 return len;
C51 COMPILER V8.10   MSCBUTIL                                                              02/19/2008 13:55:17 PAGE 8   

              }
              
              /*------------------------------------------------------------------*/
              
              void uart1_init_buffer()
              {
                 n_recv = 0;
                 ti1_shadow = 1;
              }
              
              /*------------------------------------------------------------------*/
              
              #endif // UART1_MSCB ##################################################
 440          
 441          /*------------------------------------------------------------------*/
 442          
 443          void uart_init(unsigned char port, unsigned char baud)
 444          /********************************************************************\
 445          
 446            Routine: uart_init
 447          
 448            Purpose: Initialize serial interface, user Timer 1 for UART0 and
 449                     (optionally) Timer 2 (4 for F020) for UART1
 450          
 451            Input:
 452              unsigned char baud
 453                1:    2400
 454                2:    4800
 455                3:    9600
 456                4:   19200
 457                5:   28800
 458                6:   38400
 459                7:   57600
 460                8:  115200
 461                9:  172800
 462               10:  345600
 463          
 464          \********************************************************************/
 465          {
 466   1      #if defined (CPU_C8051F310)           // 24.5 MHz
                 unsigned char code baud_table[] =
                   {0x100 - 0,    //  N/A
                    0x100 - 0,    //  N/A
                    0x100 - 0,    //  N/A
                    0x100 - 0,    //  N/A
                    0x100 - 0,    //  N/A
                    0x100 - 0,    //  N/A
                    0x100 - 213,  //  57600
                    0x100 - 106,  // 115200
                    0x100 - 71,   // 172800
                    0x100 - 35 }; // 345600
              #elif defined(CPU_C8051F320)          // 12 MHz
                 unsigned char code baud_table[] =
                   {0x100 - 0,    //  N/A
                    0x100 - 0,    //  N/A
                    0x100 - 0,    //  N/A
                    0x100 - 0,    //  N/A
                    0x100 - 208,  //  28800
                    0x100 - 156,  //  38400
                    0x100 - 104,  //  57600
                    0x100 - 52,   // 115200
                    0x100 - 35,   // 172800  2% error
C51 COMPILER V8.10   MSCBUTIL                                                              02/19/2008 13:55:17 PAGE 9   

                    0x100 - 17 }; // 345600  2% error
              #elif defined(SCS_210)                // 24.5 MHz
                 unsigned char code baud_table[] =  // UART0 via timer 2
                   {0x100 - 0,    //  N/A
                    0x100 - 0,    //  N/A
                    0x100 - 160,  //   9600  0.3% error
                    0x100 - 80,   //  19200  0.3% error
                    0x100 - 53,   //  28800  0.3% error
                    0x100 - 40,   //  38400  0.3% error
                    0x100 - 27,   //  57600  1.5% error
                    0x100 - 13,   // 115200  2.2% error
                    0x100 - 9,    // 172800  1.5% error
                    0x100 - 0 };  // N/A
                 unsigned char code baud_table1[] = // UART1 via timer 1
                   {0x100 - 106,  //   2400  0.3% error
                    0x100 - 53,   //   4800  0.3% error
                    0x100 - 27,   //   9600  1.5% error
                    0x100 - 13,   //  19200  2.2% error
                    0x100 - 9,    //  28800  1.5% error
                    0x100 - 7,    //  38400  5.1% error
                    0x100 - 0,    //  N/A
                    0x100 - 0,    //  N/A
                    0x100 - 0,    //  N/A
                    0x100 - 0};   //  N/A
              #elif defined(SUBM_260)                // 49 MHz
                 unsigned char code baud_table[] =  // UART0 via timer 2
                   {0xFB, 0x100 - 252,  //   2400
                    0xFD, 0x100 - 126,  //   4800
                    0xFE, 0x100 - 63,   //   9600
                    0xFF, 0x100 - 160,  //  19200  0.3% error
                    0xFF, 0x100 - 106,  //  28800  0.3% error
                    0xFF, 0x100 - 80,   //  38400  0.3% error
                    0xFF, 0x100 - 53,   //  57600  0.3% error
                    0xFF, 0x100 - 27,   // 115200  1.5% error
                    0xFF, 0x100 - 18,   // 172800  1.5% error
                    0xFF, 0x100 - 9 };  // 345600  1.5% error
              #elif defined(CPU_C8051F120)          // 98 MHz
 526   1         unsigned char code baud_table[] =  // UART0 via timer 2
 527   1           {0x100 - 0,    //  N/A
 528   1            0x100 - 0,    //  N/A
 529   1            0x100 - 0,    //  N/A
 530   1            0x100 - 0,    //  N/A
 531   1            0x100 - 213,  //  28800  0.2% error
 532   1            0x100 - 160,  //  38400  0.3% error
 533   1            0x100 - 106,  //  57600  0.3% error
 534   1            0x100 - 53,   // 115200  0.3% error
 535   1            0x100 - 35,   // 172800  1.3% error
 536   1            0x100 - 18 }; // 345600  1.6% error
 537   1      #if defined(UART1_MSCB) || defined(UART1_DEVICE)
                 unsigned char code baud_table1[] = // UART1 via timer 1
                   {0x100 - 0,    //  N/A
                    0x100 - 212,  //   4800  0.3% error
                    0x100 - 106,  //   9600  0.3% error
                    0x100 - 53,   //  19200  0.3% error
                    0x100 - 35,   //  28800  1.3% error
                    0x100 - 27,   //  38400  1.6% error
                    0x100 - 18,   //  57600  1.6% error
                    0x100 - 9,    // 115200  1.6% error
                    0x100 - 6,    // 172800  1.6% error
                    0x100 - 3 };  // 345600  1.6% error
              #endif
 550   1      #else                                 // 11.0592 MHz
C51 COMPILER V8.10   MSCBUTIL                                                              02/19/2008 13:55:17 PAGE 10  

                 unsigned char code baud_table[] =
                   {0x100 - 144,  //   2400
                    0x100 - 72,   //   4800
                    0x100 - 36,   //   9600
                    0x100 - 18,   //  19200
                    0x100 - 12,   //  28800
                    0x100 - 9,    //  38400
                    0x100 - 6,    //  57600
                    0x100 - 3,    // 115200
                    0x100 - 2,    // 172800
                    0x100 - 1 };  // 345600
              #endif
 563   1      
 564   1         if (port == 0) { /*---- UART0 ----*/
 565   2      
 566   2      #ifdef CPU_C8051F120
 567   2            SFRPAGE = UART0_PAGE;
 568   2      #endif
 569   2      
 570   2            SCON0 = 0xD0;                // Mode 3, 9 bit, receive enable
 571   2      
 572   2      #ifdef CPU_C8051F120
 573   2      
 574   2            SFRPAGE = UART0_PAGE;
 575   2            SSTA0 = 0x15;                // User Timer 2 for baud rate, div2 disabled
 576   2      
 577   2            SFRPAGE = TMR2_PAGE;
 578   2            TMR2CF = 0x08;               // use system clock for timer 2
 579   2      #ifdef SUBM_260
                    RCAP2H = baud_table[(baud - 1)*2];    // load high byte
                    RCAP2L = baud_table[(baud - 1)*2+1];  // load low byte
              #else
 583   2            RCAP2H = 0xFF;
 584   2            RCAP2L = baud_table[baud - 1];
 585   2      #endif
 586   2            TMR2CN = 0x04;               // start timer 2
 587   2            SFRPAGE = UART0_PAGE;
 588   2      
 589   2      #else // CPU_C8051F120
              
                    TMOD  = (TMOD & 0x0F)| 0x20; // Timer 1 8-bit counter with auto reload
              
              #if defined(CPU_C8051F310) || defined(CPU_C8051F320)
                    CKCON |= 0x08;               // use system clock
              #else
                    T2CON &= ~30;                // User Timer 1 for baud rate
                    CKCON |= 0x10;               // use system clock
              #endif
              
                    TH1 = baud_table[baud - 1];  // load initial values
                    TR1 = 1;                     // start timer 1
              
              #endif // CPU_C8051F120
 604   2      
 605   2            ES0 = 1;                     // enable serial interrupt
 606   2            PS0 = 0;                     // serial interrupt low priority
 607   2      
 608   2      
 609   2      #if defined(UART1_MSCB) || defined(UART1_DEVICE)
              
                 } else { /*---- UART1 ----*/
              
C51 COMPILER V8.10   MSCBUTIL                                                              02/19/2008 13:55:17 PAGE 11  

              #if defined(CPU_C8051F020)
                    SCON1 = 0x50;                // Mode 1, 8 bit, receive enable
              
                    T4CON = 0x34;                // timer 4 RX+TX mode
                    RCAP4H = 0xFF;
                    RCAP4L = baud_table[baud - 1];
              
                    EIE2 |= 0x40;                // enable serial interrupt
                    EIP2 &= ~0x40;               // serial interrupt low priority
              
              
              #elif defined(SCS_210)             // 24.5 MHz
                    SFRPAGE = UART1_PAGE;
                    SCON1 = 0x50;                // Mode 1, 8 bit, receive enable
              
                    SFRPAGE = TIMER01_PAGE;
                    TMOD  = (TMOD & 0x0F)| 0x20; // Timer 1 8-bit counter with auto reload
                    CKCON = 0x02;                // use SYSCLK/48 (needed by timer 0)
              
                    TH1 = baud_table1[baud - 1];
                    TR1 = 1;                     // start timer 1
              
                    EIE2 |= 0x40;                // enable serial interrupt
                    EIP2 &= ~0x40;               // serial interrupt low priority
              #elif defined(CPU_C8051F120)       // 98 MHz
                    SFRPAGE = UART1_PAGE;
              #ifdef UART1_MSCB
                    SCON1 = 0xD0;                // Mode 3, 9 bit, receive enable
              #else
                    SCON1 = 0x50;                // Mode 1, 8 bit, receive enable
              #endif
              
                    SFRPAGE = TIMER01_PAGE;
                    TMOD  = (TMOD & 0x0F)| 0x20; // Timer 1 8-bit counter with auto reload
                    CKCON = 0x02;                // use SYSCLK/48 (needed by timer 0)
              
                    TH1 = baud_table1[baud - 1];
                    TR1 = 1;                     // start timer 1
              
                    EIE2 |= 0x40;                // enable serial interrupt
                    EIP2 |= 0x40;                // serial interrupt high priority, needed in order not
                                                 // to loose data during UART0 communication
              #endif
              
                    uart1_init_buffer();
              #endif // defined(UART1_MSCB) || defined(UART1_DEVICE)
 659   2         }
 660   1      
 661   1         EA = 1;                         // general interrupt enable
 662   1      }
 663          
 664          /*------------------------------------------------------------------*/
 665          
 666          static unsigned long _systime;
 667          static unsigned long _uptime;
 668          static unsigned char _uptime_cnt;
 669          
 670          /* LED structure */
 671          
 672          struct {
 673            unsigned char mode;
 674            unsigned char timer;
C51 COMPILER V8.10   MSCBUTIL                                                              02/19/2008 13:55:17 PAGE 12  

 675            unsigned char interval;
 676            unsigned char n;
 677          } idata leds[N_LED];
 678          
 679          #ifdef LED_0
 680          sbit led_0 = LED_0;
 681          #endif
 682          #ifdef LED_1
              sbit led_1 = LED_1;
              #endif
 685          #ifdef LED_2
              sbit led_2 = LED_2;
              #endif
 688          #ifdef LED_3
              sbit led_3 = LED_3;
              #endif
 691          #ifdef LED_4
              sbit led_4 = LED_4;
              #endif
 694          #ifdef LED_5
              sbit led_5 = LED_5;
              #endif
 697          #ifdef LED_6
              sbit led_6 = LED_6;
              #endif
 700          #ifdef LED_7
              sbit led_7 = LED_7;
              #endif
 703          #ifdef LED_8
              sbit led_8 = LED_8;
              #endif
 706          #ifdef LED_9
              sbit led_9 = LED_9;
              #endif
 709          
 710          /*------------------------------------------------------------------*/
 711          
 712          void sysclock_reset(void)
 713          /********************************************************************\
 714          
 715            Routine: sysclock_reset
 716          
 717            Purpose: Reset system clock and uptime counter
 718          
 719          *********************************************************************/
 720          {
 721   1         unsigned char i;
 722   1      
 723   1         _systime = 0;
 724   1         _uptime = 0;
 725   1         _uptime_cnt = 100;
 726   1      
 727   1         for (i=0 ; i<N_LED ; i++) {
 728   2           leds[i].mode = 0;
 729   2           leds[i].timer = 0;
 730   2           leds[i].interval = 0;
 731   2           leds[i].n = 0;
 732   2         }
 733   1      }
 734          
 735          /*------------------------------------------------------------------*/
 736          
C51 COMPILER V8.10   MSCBUTIL                                                              02/19/2008 13:55:17 PAGE 13  

 737          
 738          void sysclock_init(void)
 739          /********************************************************************\
 740          
 741            Routine: sysclock_init
 742          
 743            Purpose: Initial sytem clock via timer 0
 744          
 745          *********************************************************************/
 746          {
 747   1         EA = 1;                      // general interrupt enable
 748   1         ET0 = 1;                     // Enable Timer 0 interrupt
 749   1         PT1 = 0;                     // Interrupt priority low
 750   1      
 751   1      #ifdef CPU_C8051F120
 752   1         SFRPAGE = TIMER01_PAGE;
 753   1      #endif
 754   1      
 755   1         TMOD = (TMOD & 0x0F) | 0x01; // 16-bit counter
 756   1      #if defined(SCS_210)
                 CKCON = 0x02;                // use SYSCLK/48
                 TH0 = 0xEC;                  // load initial value (24.5 MHz SYSCLK)
              #elif defined(CPU_C8051F120)
 760   1         CKCON = 0x02;                // use SYSCLK/48 (98 MHz SYSCLK)
 761   1         TH0 = 0xAF;                  // load initial value
 762   1      #elif defined(CPU_C8051F310)
                 CKCON = 0x00;                // use SYSCLK/12
                 TH0 = 0xAF;                  // load initial value (24.5 MHz SYSCLK)
              #else
                 CKCON = 0x00;                // use SYSCLK/12
                 TH0 = 0xDB;                  // load initial value
              #endif
 769   1      
 770   1         TL0 = 0x00;
 771   1         TR0 = 1;                     // start timer 0
 772   1      
 773   1         sysclock_reset();
 774   1      }
 775          
 776          /*------------------------------------------------------------------*/
 777          
 778          void led_int() reentrant
 779          {
 780   1      unsigned char led_i;
 781   1      
 782   1         /* manage blinking LEDs */
 783   1         for (led_i=0 ; led_i<N_LED ; led_i++) {
 784   2            if (leds[led_i].n > 0 && leds[led_i].timer == 0) {
 785   3               if ((leds[led_i].n & 1) && leds[led_i].n > 1)
 786   3                  led_set(led_i, LED_ON);
 787   3               else
 788   3                  led_set(led_i, LED_OFF);
 789   3      
 790   3               leds[led_i].n--;
 791   3               if (leds[led_i].n)
 792   3                  leds[led_i].timer = leds[led_i].interval;
 793   3            }
 794   2      
 795   2            if (leds[led_i].timer)
 796   2               leds[led_i].timer--;
 797   2      
 798   2            if (leds[led_i].n == 0)
C51 COMPILER V8.10   MSCBUTIL                                                              02/19/2008 13:55:17 PAGE 14  

 799   2               led_set(led_i, LED_OFF);
 800   2         }
 801   1      }
 802          
 803          /*------------------------------------------------------------------*/
 804          
 805          extern void tcp_timer(void);
 806          void watchdog_int(void) reentrant;
 807          
 808          void timer0_int(void) interrupt 1
 809          /********************************************************************\
 810          
 811            Routine: timer0_int
 812          
 813            Purpose: Timer 0 interrupt routine for 100Hz system clock
 814          
 815                     Reload value = 0x10000 - 0.01 / (11059200/12)
 816          
 817          \********************************************************************/
 818          {
 819   1      #ifdef SUBM_260
                 tcp_timer();
              #else /* SUBM_260 */
 822   1      
 823   1      #if defined(SCS_210)
                 TH0 = 0xEC;                  // for 24.5 MHz clock / 48
              #elif defined(CPU_C8051F120)
 826   1         TH0 = 0xAF;                  // for 98 MHz clock   / 48
 827   1      #elif defined(CPU_C8051F310)
                 TH0 = 0xAF;                  // for 24.5 MHz clock / 12 
              #else
                 TH0 = 0xDC;                  // reload timer values, let LSB freely run
              #endif
 832   1      
 833   1      #endif /* !SUBM_260 */
 834   1         _systime++;                  // increment system time
 835   1         _uptime_cnt--;
 836   1         if (_uptime_cnt == 0) {      // once every second
 837   2            _uptime++;
 838   2            _uptime_cnt = 100;
 839   2         }
 840   1         
 841   1         led_int();
 842   1         watchdog_int();
 843   1      }
 844          
 845          
 846          /*------------------------------------------------------------------*/
 847          
 848          void led_mode(unsigned char led, unsigned char flag) reentrant
 849          /********************************************************************\
 850          
 851            Routine: led_mode
 852          
 853            Purpose: Set LED mode
 854          
 855            Input:
 856              int led               0 for primary, 1 for secondary
 857              int flag              Noninverted (0) / Inverted (1)
 858          
 859          \********************************************************************/
 860          {
C51 COMPILER V8.10   MSCBUTIL                                                              02/19/2008 13:55:17 PAGE 15  

 861   1         if (led < N_LED)
 862   1            leds[led].mode = flag;
 863   1      }
 864          
 865          /*------------------------------------------------------------------*/
 866          
 867          void led_blink(unsigned char led, unsigned char n, int interval) reentrant
 868          /********************************************************************\
 869          
 870            Routine: blink led
 871          
 872            Purpose: Blink primary or secondary LED for a couple of times
 873          
 874            Input:
 875              int led               0 for primary, 1 for secondary, ...
 876              int interval          Blink interval in ms
 877              int n                 Number of blinks
 878          
 879          \********************************************************************/
 880          {
 881   1         if (led < N_LED) {
 882   2            if (leds[led].n == 0 && leds[led].timer == 0) {
 883   3               leds[led].n = n*2+1;
 884   3               leds[led].interval = interval / 10;
 885   3               leds[led].timer = 0;
 886   3            }
 887   2         }
 888   1      }
 889          
 890          /*------------------------------------------------------------------*/
 891          
 892          void led_set(unsigned char led, unsigned char flag) reentrant 
 893          {
 894   1         /* invert on/off if mode == 1 */
 895   1         if (led < N_LED && leds[led].mode)
 896   1            flag = !flag;
 897   1      
 898   1      #ifdef LED_0
 899   1         if (led == 0)
 900   1            led_0 = flag;
 901   1      #endif
 902   1      #ifdef LED_1
                 if (led == 1)
                    led_1 = flag;
              #endif
 906   1      #ifdef LED_2
                 if (led == 2)
                    led_2 = flag;
              #endif
 910   1      #ifdef LED_3
                 if (led == 3)
                    led_3 = flag;
              #endif
 914   1      #ifdef LED_4
                 if (led == 4)
                    led_4 = flag;
              #endif
 918   1      #ifdef LED_5
                 if (led == 5)
                    led_5 = flag;
              #endif
 922   1      #ifdef LED_6
C51 COMPILER V8.10   MSCBUTIL                                                              02/19/2008 13:55:17 PAGE 16  

                 if (led == 6)
                    led_6 = flag;
              #endif
 926   1      #ifdef LED_7
                 if (led == 7)
                    led_7 = flag;
              #endif
 930   1      #ifdef LED_8
                 if (led == 8)
                    led_8 = flag;
              #endif
 934   1      #ifdef LED_9
                 if (led == 9)
                    led_9 = flag;
              #endif
 938   1      }
 939          
 940          /*------------------------------------------------------------------*/
 941          
 942          unsigned long time(void)
 943          /********************************************************************\
 944          
 945            Routine: time
 946          
 947            Purpose: Return system time in units of 10ms
 948          
 949          \********************************************************************/
 950          {
 951   1         unsigned long t;
 952   1      
 953   1         DISABLE_INTERRUPTS;
 954   1         t = _systime;
 955   1         ENABLE_INTERRUPTS;
 956   1         return t;
 957   1      }
 958          
 959          /*------------------------------------------------------------------*/
 960          
 961          unsigned long uptime(void)
 962          /********************************************************************\
 963          
 964            Routine: uptime
 965          
 966            Purpose: Return system uptime in seconds
 967          
 968          \********************************************************************/
 969          {
 970   1         unsigned long t;
 971   1      
 972   1         DISABLE_INTERRUPTS;
 973   1         t = _uptime;
 974   1         ENABLE_INTERRUPTS;
 975   1         return t;
 976   1      }
 977          
 978          /*------------------------------------------------------------------*/
 979          
 980          #ifdef USE_WATCHDOG
 981          #define DEFAULT_WATCHDOG_TIMEOUT 10    // 10 seconds
 982          unsigned short watchdog_timer;
 983          unsigned char  watchdog_timeout = DEFAULT_WATCHDOG_TIMEOUT;
 984          bit            watchdog_on;
C51 COMPILER V8.10   MSCBUTIL                                                              02/19/2008 13:55:17 PAGE 17  

 985          #endif
 986          
 987          void watchdog_refresh(unsigned char from_interrupt) reentrant
 988          /********************************************************************\
 989          
 990            Routine: watchdog_refresh
 991          
 992            Purpose: Resets watchdog, has to be called regularly, otherwise
 993                     the watchdog issues a reset. If called from an interrupt
 994                     routine, just reset the hardware watchdog, but not the
 995                     watchdog timer. Reset the watchdog timer only when called
 996                     from the user loop, to ensure that the main user loop
 997                     is running.
 998          
 999            Input:
1000              unsigned char from_interrupt  0 if called from normal user loop,
1001                                            1 if called from interrupt routine
1002          
1003          
1004          \********************************************************************/
1005          {
1006   1         if (from_interrupt);
1007   1      
1008   1      #ifdef USE_WATCHDOG
1009   1         if (from_interrupt == 0)
1010   1            watchdog_timer = 0;
1011   1      
1012   1         if (watchdog_on && watchdog_timer < watchdog_timeout*100) {
1013   2      
1014   2      #ifdef EXT_WATCHDOG
                    EXT_WATCHDOG_PIN = !EXT_WATCHDOG_PIN;
              #else
1017   2      #if defined(CPU_C8051F310) || defined(CPU_C8051F320)
                    PCA0CPH4 = 0x00;
              #else
1020   2            WDTCN = 0xA5;
1021   2      #endif
1022   2      #endif // EXT_WATCHDOG
1023   2      
1024   2         }
1025   1         
1026   1      #endif
1027   1      }
1028          
1029          /*------------------------------------------------------------------*/
1030          
1031          void watchdog_enable(unsigned char timeout)
1032          /********************************************************************\
1033          
1034            Routine: watchdog_enable
1035          
1036            Purpose: Enables watchdog
1037          
1038            Input:
1039              unsigned char timeout    Watchdog timeout in seconds
1040          
1041          \********************************************************************/
1042          {
1043   1         if (timeout);
1044   1      #ifdef USE_WATCHDOG
1045   1      
1046   1         watchdog_on = 1;
C51 COMPILER V8.10   MSCBUTIL                                                              02/19/2008 13:55:17 PAGE 18  

1047   1         watchdog_timer = 0;
1048   1         if (timeout)
1049   1            watchdog_timeout = timeout;
1050   1         else
1051   1            watchdog_timeout = DEFAULT_WATCHDOG_TIMEOUT;
1052   1      
1053   1      #ifndef EXT_WATCHDOG
1054   1      #if defined(CPU_C8051F310) || defined(CPU_C8051F320)
                 PCA0MD   = 0x00;             // disable watchdog
                 PCA0CPL4 = 255;              // 65.5 msec @ 12 MHz
                 PCA0MD   = 0x40;             // enable watchdog
                 PCA0CPH4 = 0x00;             // reset watchdog
              
                 RSTSRC   = 0x06;             // enable missing clock detector and 
                                              // VDD monitor as reset sourse
              #else /* CPU_C8051F310 */
1063   1      
1064   1         WDTCN    = 0x07;             // 95 msec (11.052 MHz) / 21msec (49 MHz)
1065   1         WDTCN    = 0xA5;             // start watchdog
1066   1      
1067   1      #if defined(CPU_C8051F120)
1068   1         SFRPAGE = LEGACY_PAGE;
1069   1         RSTSRC  = 0x04;              // enable missing clock detector
1070   1      #else
                 OSCICN |= 0x80;              // enable missing clock detector
                 RSTSRC  = 0x09;              // enable reset pin and watchdog reset
              #endif
1074   1      
1075   1      #endif /* not CPU_C8051F310 */
1076   1      #endif /* not EXT_WATCHDOG */
1077   1      #endif /* USE_WATCHDOG */
1078   1      }
1079          
1080          /*------------------------------------------------------------------*/
1081          
1082          void watchdog_disable(void)
1083          /********************************************************************\
1084          
1085            Routine: watchdog_disable
1086          
1087            Purpose: Disables watchdog
1088          
1089          \********************************************************************/
1090          {
1091   1      #ifdef USE_WATCHDOG
1092   1         watchdog_on = 0;
1093   1         watchdog_timer = 0;
1094   1      #endif
1095   1      
1096   1      #if defined(CPU_C8051F310) || defined(CPU_C8051F320)
                 PCA0MD = 0x00;
              #else
1099   1         WDTCN  = 0xDE;
1100   1         WDTCN  = 0xAD;
1101   1      #endif
1102   1      }
1103          
1104          /*------------------------------------------------------------------*/
1105          
1106          void watchdog_int(void) reentrant
1107          /********************************************************************\
1108          
C51 COMPILER V8.10   MSCBUTIL                                                              02/19/2008 13:55:17 PAGE 19  

1109            Routine: watchdog_int
1110          
1111            Purpose: Called by 100Hz interrupt routine to refresh watchdog
1112          
1113          \********************************************************************/
1114          {
1115   1      #ifdef USE_WATCHDOG
1116   1      
1117   1         /* timer expires after 10 sec of inactivity */
1118   1         watchdog_timer++;
1119   1         if (watchdog_on && watchdog_timer < watchdog_timeout*100) {
1120   2      
1121   2      #ifdef EXT_WATCHDOG
                    EXT_WATCHDOG_PIN = !EXT_WATCHDOG_PIN;
              #else
1124   2      #if defined(CPU_C8051F310) || defined(CPU_C8051F320)
                    PCA0CPH4 = 0x00;
              #else
1127   2            WDTCN = 0xA5;
1128   2      #endif
1129   2      #endif // EXT_WATCHDOG
1130   2      
1131   2         }
1132   1      #endif
1133   1      }
1134          
1135          /*------------------------------------------------------------------*\
1136          
1137          
1138          /********************************************************************\
1139          
1140            Routine: delay_ms, delay_us
1141          
1142            Purpose: Delay functions for 11.0520 MHz quartz
1143          
1144          \********************************************************************/
1145          
1146          void delay_ms(unsigned int ms)
1147          {
1148   1         unsigned int i;
1149   1      
1150   1         for (i = 0; i < ms; i++) {
1151   2            delay_us(1000);
1152   2            watchdog_refresh(1);
1153   2         }
1154   1      }
1155          
1156          void delay_us(unsigned int us)
1157          {
1158   1      #if defined(CPU_C8051F120) || defined(CPU_C8051F310)
1159   1         unsigned char j;
1160   1      #endif
1161   1      
1162   1         unsigned char i;
1163   1         unsigned int remaining_us;
1164   1      
1165   1         if (us <= 250) {
1166   2            for (i = (unsigned char) us; i > 0; i--) {
1167   3      #if defined(SCS_210)
                       _nop_();
                       for (j=3 ; j>0 ; j--)
                          _nop_();
C51 COMPILER V8.10   MSCBUTIL                                                              02/19/2008 13:55:17 PAGE 20  

              #elif defined(CPU_C8051F120)
1172   3               for (j=22 ; j>0 ; j--)
1173   3                  _nop_();
1174   3      #elif defined(CPU_C8051F310)
                       _nop_();
                       for (j=3 ; j>0 ; j--)
                          _nop_();
              #elif defined(CPU_C8051F320)
                       _nop_();
                       _nop_();
              #else
                       _nop_();
              #endif
1184   3            }
1185   2         } else {
1186   2            remaining_us = us;
1187   2            while (remaining_us > 250) {
1188   3               delay_us(250);
1189   3               remaining_us -= 250;
1190   3            }
1191   2            if (us > 0)
1192   2               delay_us(remaining_us);
1193   2         }
1194   1      }
1195          
1196          /*------------------------------------------------------------------*/
1197          
1198          #ifdef HAVE_EEPROM
1199          
1200          void eeprom_read(void * dst, unsigned char len, unsigned short *offset)
1201          /********************************************************************\
1202          
1203            Routine: eeprom_read
1204          
1205            Purpose: Read from internal EEPROM
1206          
1207            Input:
1208              unsigned char idata *dst    Destination in IDATA memory
1209              unsigned char len           Number of bytes to copy
1210              unsigend char *offset       Offset in EEPROM in bytes, gets
1211                                          adjusted after read
1212          
1213          \********************************************************************/
1214          {
1215   1         unsigned char i;
1216   1         unsigned char code *p;
1217   1         unsigned char *d;
1218   1      
1219   1         watchdog_refresh(1);
1220   1      
1221   1         p = EEPROM_OFFSET + *offset;        // read from 128-byte EEPROM page
1222   1         d = dst;
1223   1      
1224   1         for (i = 0; i < len; i++)
1225   1            d[i] = p[i];
1226   1      
1227   1         *offset += len;
1228   1      }
1229          
1230          /*------------------------------------------------------------------*/
1231          
1232          void eeprom_write(void * src, unsigned char len, unsigned short *offset)
C51 COMPILER V8.10   MSCBUTIL                                                              02/19/2008 13:55:17 PAGE 21  

1233          /********************************************************************\
1234          
1235            Routine: eeprom_write
1236          
1237            Purpose: Read from internal EEPROM
1238          
1239            Input:
1240              unsigned char idata *src    Source in IDATA memory
1241              unsigned char len           Number of bytes to copy
1242              unsigend char offset        Offset in EEPROM in bytes, gets
1243                                          adjusted after write
1244          
1245          \********************************************************************/
1246          {
1247   1         unsigned char xdata * idata p;      // xdata pointer causes MOVX command
1248   1         unsigned char idata i, b;
1249   1         unsigned char * idata s;
1250   1      
1251   1         if (_flkey != 0xF1)
1252   1            return;
1253   1      
1254   1         watchdog_disable();
1255   1         DISABLE_INTERRUPTS;
1256   1      
1257   1      #ifdef CPU_C8051F120
1258   1         SFRPAGE = LEGACY_PAGE;
1259   1      #endif
1260   1      
1261   1      #if defined(CPU_C8051F000)
                 FLSCL = (FLSCL & 0xF0) | 0x08;  // set timer for 11.052 MHz clock
              #elif defined(CPU_C8051F020) || defined(CPU_C8051F120)
1264   1         FLSCL = FLSCL | 1;           // enable flash writes
1265   1      #endif
1266   1         PSCTL = 0x01;                // allow write
1267   1      
1268   1         p = EEPROM_OFFSET + *offset;
1269   1         s = src;
1270   1      
1271   1         for (i = 0; i < len; i++) {  // write data
1272   2            b = *s++;
1273   2      
1274   2      #if defined(CPU_C8051F310) || defined(CPU_C8051F320)
                    FLKEY = 0xA5;             // write flash key code
                    FLKEY = _flkey;
              #endif
1278   2      
1279   2            *p++ = b;
1280   2         }
1281   1      
1282   1         PSCTL = 0x00;                // don't allow write
1283   1         FLSCL = FLSCL & 0xF0;
1284   1      
1285   1         *offset += len;
1286   1      
1287   1         ENABLE_INTERRUPTS;
1288   1         watchdog_enable(0);
1289   1      }
1290          
1291          /*------------------------------------------------------------------*/
1292          
1293          void eeprom_erase(void)
1294          /********************************************************************\
C51 COMPILER V8.10   MSCBUTIL                                                              02/19/2008 13:55:17 PAGE 22  

1295          
1296            Routine: eeprom_erase
1297          
1298            Purpose: Erase parameter EEPROM page
1299          
1300          \********************************************************************/
1301          {
1302   1         unsigned char idata i;
1303   1         unsigned char xdata * idata p;
1304   1      
1305   1         if (_flkey != 0xF1)
1306   1            return;
1307   1      
1308   1         DISABLE_INTERRUPTS;
1309   1         watchdog_disable();
1310   1      
1311   1      #ifdef CPU_C8051F120
1312   1         SFRPAGE = LEGACY_PAGE;
1313   1      #endif
1314   1      
1315   1      #if defined(CPU_C8051F000)
                 FLSCL = (FLSCL & 0xF0) | 0x08;       // set timer for 11.052 MHz clock
              #elif defined(CPU_C8051F020) || defined(CPU_C8051F120)
1318   1         FLSCL = FLSCL | 1;                   // enable flash writes
1319   1      #endif
1320   1         PSCTL = 0x03;                        // allow write and erase
1321   1      
1322   1      #if defined(CPU_C8051F310) || defined(CPU_C8051F320)
                 p = EEPROM_OFFSET;
                 for (i=0 ; i<N_EEPROM_PAGE ; i++) {
                    FLKEY = 0xA5;                        // write flash key code
                    FLKEY = _flkey;
                    *p = 0;                              // erase page
                    watchdog_refresh(1);
                    p += 512;
                 }
              #else
1332   1         p = EEPROM_OFFSET;
1333   1         for (i=0 ; i<N_EEPROM_PAGE ; i++) {
1334   2            *p = 0; // erase page
1335   2            watchdog_refresh(1);
1336   2            p += 512;
1337   2         }
1338   1      #endif
1339   1      
1340   1         PSCTL = 0x00;                        // don't allow write
1341   1         FLSCL = FLSCL & 0xF0;
1342   1      
1343   1         ENABLE_INTERRUPTS;
1344   1         watchdog_enable(0);
1345   1      }
1346          
1347          /*------------------------------------------------------------------*/
1348          
1349          void eeprom_flash(void)
1350          /********************************************************************\
1351          
1352            Routine: eeprom_flash
1353          
1354            Purpose: Write system and user parameters to EEPROM
1355          
1356          \********************************************************************/
C51 COMPILER V8.10   MSCBUTIL                                                              02/19/2008 13:55:17 PAGE 23  

1357          {
1358   1         unsigned char i, adr;
1359   1         unsigned short magic, offset;
1360   1      
1361   1         eeprom_erase();
1362   1      
1363   1         offset = 0;
1364   1      
1365   1         // system info (node address etc...)
1366   1         eeprom_write(&sys_info, sizeof(SYS_INFO), &offset);
1367   1      
1368   1         // magic
1369   1         magic = 0x1234;
1370   1         eeprom_write(&magic, 2, &offset);
1371   1      
1372   1         // user channel variables
1373   1         for (adr = 0 ; adr < _n_sub_addr ; adr++)
1374   1            for (i = 0; variables[i].width; i++)
1375   1               eeprom_write((char *)variables[i].ud + _var_size*adr,
1376   1                            variables[i].width, &offset);
1377   1      
1378   1         // magic
1379   1         magic = 0x1234;
1380   1         eeprom_write(&magic, 2, &offset);
1381   1      
1382   1         _flkey = 0;
1383   1      }
1384          
1385          /*------------------------------------------------------------------*/
1386          
1387          unsigned char eeprom_retrieve(unsigned char flag)
1388          /********************************************************************\
1389          
1390            Routine: eeprom_retrieve
1391          
1392            Purpose: Retrieve system and user parameters from EEPROM
1393          
1394          \********************************************************************/
1395          {
1396   1         unsigned char i, adr, status;
1397   1         unsigned short magic, offset;
1398   1      
1399   1         offset = 0;
1400   1         status = 0;
1401   1      
1402   1         // system info (node address etc...)
1403   1         eeprom_read(&sys_info, sizeof(SYS_INFO), &offset);
1404   1      
1405   1         // check for first magic
1406   1         eeprom_read(&magic, 2, &offset);
1407   1         if (magic == 0x1234)
1408   1            status |= (1 << 0);
1409   1      
1410   1         // user channel variables
1411   1         if (flag) {
1412   2            for (adr = 0 ; adr < _n_sub_addr ; adr++)
1413   2               for (i = 0; variables[i].width; i++)
1414   2                  eeprom_read((char *)variables[i].ud + _var_size*adr,
1415   2                              variables[i].width, &offset);
1416   2         
1417   2            // check for second magic
1418   2            eeprom_read(&magic, 2, &offset);
C51 COMPILER V8.10   MSCBUTIL                                                              02/19/2008 13:55:17 PAGE 24  

1419   2            if (magic == 0x1234)
1420   2               status |= (1 << 1);
1421   2         } else
1422   1            status |= (1 << 1);
1423   1      
1424   1         return status;
1425   1      }
1426          
1427          #endif /* HAVE_EEPROM */
1428          
1429          /*------------------------------------------------------------------*/
1430          
1431          #ifdef HAVE_LCD
              
              bit lcd_present;
              
              /********************************************************************\
              
                Routine: lcd_setup, lcd_clear, lcd_goto, lcd_puts, putchar
              
                Purpose: LCD functions for HD44780/KS0066 compatible LCD displays
              
                         Since putchar is used by printf, this function puts its
                         output to the LCD as well
              
              \********************************************************************/
              
              #define LCD P2                  // LCD display connected to port2
              
              #if defined (SCS_2000)  // new SCS_2000, different from prototype!
              sbit LCD_RS  = P1 ^ 4;
              sbit LCD_R_W = P1 ^ 5;
              sbit LCD_E   = P1 ^ 6;
              sbit LCD_1D  = P1 ^ 0;
              sbit LCD_2D  = P1 ^ 1;
              #elif defined (SCS_900) || defined(SCS_1000) || defined (SCS_1001)
              sbit LCD_RS  = LCD ^ 3;
              sbit LCD_R_W = LCD ^ 2;
              sbit LCD_E   = LCD ^ 1;
              #else
              sbit LCD_RS  = LCD ^ 1;
              sbit LCD_R_W = LCD ^ 2;
              sbit LCD_E   = LCD ^ 3;
              #endif
              
              sbit LCD_DB4 = LCD ^ 4;
              sbit LCD_DB5 = LCD ^ 5;
              sbit LCD_DB6 = LCD ^ 6;
              sbit LCD_DB7 = LCD ^ 7;
              
              sbit LCD_CLK = LCD ^ 7;         // pins for 4021 shift register
              sbit LCD_P_W = LCD ^ 6;
              sbit LCD_SD  = LCD ^ 0;
              
              /*------------------------------------------------------------------*/
              
              void lcd_out(unsigned char d, bit df)
              {
                 unsigned char timeout;
              
                 if (!lcd_present)
                    return;
C51 COMPILER V8.10   MSCBUTIL                                                              02/19/2008 13:55:17 PAGE 25  

              
                 LCD = LCD | 0xF0;            // data input
              #if defined(CPU_C8051F120)
                 SFRPAGE = CONFIG_PAGE;
                 P2MDOUT |= 0x0F;
              #ifdef SCS_2000
                 LCD_1D = 0;                  // b to a for data
              #endif
              #else
                 PRT2CF = 0x0F;
              #endif
                 LCD_RS = 0;                  // select BF
                 LCD_R_W = 1;
                 delay_us(1);
                 LCD_E = 1;
              
                 for (timeout = 0 ; timeout < 200 ; timeout++) {
                   delay_us(10);              // let signals settle
                   if (!LCD_DB7)              // loop if busy
                     break;
                 }
              
                 LCD_E = 0;
                 delay_us(1);
                 LCD_R_W = 0;
              #if defined(CPU_C8051F120)
              #ifdef SCS_2000
                 LCD_1D = 1;                  // a to b for data
              #endif
                 SFRPAGE = CONFIG_PAGE;
                 P2MDOUT = 0xFF;              // data output
              #else
                 PRT2CF = 0xFF;               // data output
              #endif
                 delay_us(1);
              
                 /* high nibble, preserve P0.0 */
                 LCD = (LCD & 0x01) | (d & 0xF0);
                 LCD_RS = df;
                 delay_us(1);
              
                 LCD_E = 1;
                 delay_us(1);
                 LCD_E = 0;
                 delay_us(1);
              
                 /* now nibble */
                 LCD = (LCD & 0x01) | ((d << 4) & 0xF0);
                 LCD_RS = df;
                 delay_us(1);
              
                 LCD_E = 1;
                 delay_us(1);
                 LCD_E = 0;
                 delay_us(1);
              }
              
              /*------------------------------------------------------------------*/
              
              #if defined(SCS_900) || defined(SCS_1001) || defined(SCS_2000) // 4-line LCD display with KS0078 controlle
             -r
              
C51 COMPILER V8.10   MSCBUTIL                                                              02/19/2008 13:55:17 PAGE 26  

              void lcd_nibble(unsigned char d)
              {
                 LCD &= ~(0xF0);
                 LCD |= (d & 0xF0);        // high nibble
                 LCD_E = 1;
                 delay_us(1);
                 LCD_E = 0;
                 delay_us(1);
              
                 LCD &= ~(0xF0);
                 LCD |= ((d << 4) & 0xF0); // low nibble
                 LCD_E = 1;
                 delay_us(1);
                 LCD_E = 0;
                 delay_us(1);
              
                 delay_us(100);
              }
              
              #endif
              
              void lcd_setup()
              {
                 unsigned i=0;
              
                 LCD_E   = 0;
                 LCD_R_W = 0;
                 LCD_RS  = 0;
              
              #if defined(CPU_C8051F120)
                 SFRPAGE = CONFIG_PAGE;
                 P2MDOUT = 0xFF;             // all push-pull
              #ifdef SCS_2000
                 P1MDOUT |= 0x03;
                 LCD_1D = 1;                 // a to b for data
                 LCD_2D = 1;                 // a to b for control
              #endif
              #else
                 PRT2CF = 0xFF;              // all push-pull
              #endif
              
              #if defined(SCS_900) || defined(SCS_1001) || defined(SCS_2000) // 4-line LCD display with KS0078 controlle
             -r
              
                 LCD &= ~(0xFE);
                 LCD |= 0x20;  // set 4-bit interface
                 LCD_E = 1;
                 delay_us(1);
                 LCD_E = 0;
                 delay_ms(1);
                 lcd_nibble(0x20); // function set: 4-bit, RE=0
              
                 // test if LCD present
              
                 LCD = LCD | 0xF0;            // data input
              #if defined(CPU_C8051F120)
                 SFRPAGE = CONFIG_PAGE;
                 P2MDOUT |= 0x0F;
              #ifdef SCS_2000
                 LCD_1D = 0;                  // b to a for data
              #endif
              #else
C51 COMPILER V8.10   MSCBUTIL                                                              02/19/2008 13:55:17 PAGE 27  

                 PRT2CF = 0x0F;
              #endif
                 LCD_RS = 0;                  // select BF
                 LCD_R_W = 1;
                 delay_us(1);
                 LCD_E = 1;
                 delay_us(100);               // let signal settle
                 if (LCD_DB7) {
                    lcd_present = 0;
                    return;
                 }
              
                 lcd_present = 1;
              
                 lcd_out(0x24, 0); // function set: 4-bit, RE=1
                 lcd_out(0x0B, 0); // ext function set: 4-line display, inverting cursor
                 lcd_out(0x20, 0); // function set: 4-bit, RE=0
                 lcd_out(0x0C, 0); // display on
                 lcd_out(0x01, 0); // clear display
                 lcd_out(0x06, 0); // entry mode: incrementing
              
              #else // 2-line LCD display with KS0066 controller
              
                 LCD &= ~(0xFE);
                 delay_ms(15);
                 LCD |= 0x30;
              
                 LCD_E = 1;
                 delay_us(1);
                 LCD_E = 0;
                 delay_ms(5);
              
                 LCD_E = 1;
                 delay_us(1);
                 LCD_E = 0;
                 delay_ms(1);
              
                 LCD_E = 1;
                 delay_us(1);
                 LCD_E = 0;
              
                 LCD = 0x20;                  // set 4-bit interface
                 LCD_E = 1;
                 delay_us(1);
                 LCD_E = 0;
              
                 // test if LCD present
              
                 LCD = LCD | 0xF0;            // data input
              #if defined(CPU_C8051F120)
                 SFRPAGE = CONFIG_PAGE;
                 P2MDOUT = 0x0F;
              #else
                 PRT2CF = 0x0F;
              #endif
                 LCD_RS = 0;                  // select BF
                 LCD_R_W = 1;
                 delay_us(1);
                 LCD_E = 1;
                 delay_us(100);               // let signal settle
                 if (LCD_DB7) {
                    lcd_present = 0;
C51 COMPILER V8.10   MSCBUTIL                                                              02/19/2008 13:55:17 PAGE 28  

                    return;
                 }
              
                 lcd_present = 1;
              
                 lcd_out(0x2C, 0);            // select 2 lines, big font
                 lcd_out(0x0C, 0);            // display on
                 lcd_out(0x01, 0);            // clear display
                 lcd_out(0x06, 0);            // entry mode
              #endif
              }
              
              /*------------------------------------------------------------------*/
              
              void lcd_clear()
              {
                 lcd_out(0x01, 0);
                 lcd_goto(0, 0);
              }
              
              void lcd_cursor(unsigned char flag)
              {
                 if (flag)
                    lcd_out(0x0F, 0); // display on, curson on, blink on
                 else
                    lcd_out(0x0C, 0); // display on, cursor off, blink off
              }
              
              /*------------------------------------------------------------------*/
              
              void lcd_goto(char x, char y)
              {
              
              #if defined(SCS_900) || defined(SCS_1001) || defined(SCS_2000)
                 /* goto position x(0..19), y(0..3) */
                 lcd_out((x & 0x1F) | (0x80) | ((y & 0x03) << 5), 0);
              #else
                 /* goto position x(0..19), y(0..1) */
                 lcd_out((x & 0x1F) | (0x80) | ((y & 0x01) << 6), 0);
              #endif
              }
              
              /*------------------------------------------------------------------*/
              
              char putchar(char c)
              {
                 if (c != '\r' && c != '\n')
                    lcd_out(c, 1);
                 return c;
              }
              
              /*------------------------------------------------------------------*/
              
              void lcd_puts(char *str)
              {
                 while (*str)
                    lcd_out(*str++, 1);
              }
              
              #endif // HAVE_LCD
1725          
1726          /*------------------------------------------------------------------*/
C51 COMPILER V8.10   MSCBUTIL                                                              02/19/2008 13:55:17 PAGE 29  

1727          
1728          #ifdef HAVE_RTC
              
              sbit RTC_IO  = P1 ^ 2;
              sbit RTC_CLK = P1 ^ 3;
              
              /********************************************************************\
              
                Routine: Real time clock (RTC) routines
              
                Purpose: Read and set date/time on DS1302 RTC chip on SCS-2001
              
              \********************************************************************/
              
              
              /*------------------------------------------------------------------*/
              
              void rtc_output(unsigned char d)
              {
                 unsigned char i;
              
                 for (i=0 ; i<8 ; i++) {
                    RTC_IO = d & 0x01;
                    delay_us(10);
                    RTC_CLK = 1;
                    delay_us(10);
                    RTC_CLK = 0;
              
                    d >>= 1;
                 }
              }
              
              /*------------------------------------------------------------------*/
              
              unsigned char rtc_read_byte(unsigned char adr)
              {
                 unsigned char idata i, d, m;
              
                 RTC_CLK = 0;
              
                 SFRPAGE = DAC1_PAGE;
                 DAC1L = 0xFF;
                 DAC1H = 0x0F;
              
                 delay_us(10); // wait for DAC
              
                 /* switch port to output */
                 SFRPAGE = CONFIG_PAGE;
                 P1MDOUT |= 0x04; 
              
                 rtc_output(adr);
              
                 /* switch port to input */
                 SFRPAGE = CONFIG_PAGE;
                 P1MDOUT &= ~ 0x04;
                 RTC_IO = 1;
              
                 delay_us(10);
                 for (i=d=0,m=1 ; i<8 ; i++) {
                    if (RTC_IO)
                       d |= m;
                    RTC_CLK = 1;
C51 COMPILER V8.10   MSCBUTIL                                                              02/19/2008 13:55:17 PAGE 30  

                    delay_us(10);
                    RTC_CLK = 0;
                    delay_us(10);
                    m <<= 1;
                 }
              
                 SFRPAGE = DAC1_PAGE;
                 DAC1L = 0;
                 DAC1H = 0;
              
                 delay_us(10); // wait for DAC
              
                 return d;
              }
              
              /*------------------------------------------------------------------*/
              
              void rtc_read(unsigned char d[6])
              {
                 unsigned char idata i, j, b, m;
              
                 RTC_CLK = 0;
              
                 SFRPAGE = DAC1_PAGE;
                 DAC1L = 0xFF;
                 DAC1H = 0x0F;
              
                 delay_us(10); // wait for DAC
              
                 /* switch port to output */
                 SFRPAGE = CONFIG_PAGE;
                 P1MDOUT |= 0x04; 
              
                 rtc_output(0xBF); // burst read
              
                 /* switch port to input */
                 SFRPAGE = CONFIG_PAGE;
                 P1MDOUT &= ~ 0x04;
                 RTC_IO = 1;
              
                 delay_us(10); // wait for RTC output
              
                 for (j=0 ; j<7 ; j++) {
                    for (i=b=0,m=1 ; i<8 ; i++) {
                       if (RTC_IO)
                          b |= m;
                       RTC_CLK = 1;
                       delay_us(10);
                       RTC_CLK = 0;
                       delay_us(10);
                       m <<= 1;
                    }
              
                    if (j<3)
                      d[5-j] = b;
                    else if (j < 5)
                      d[j-3] = b;
                    else if (j == 6)
                      d[2] = b;
                 }
              
                 SFRPAGE = DAC1_PAGE;
C51 COMPILER V8.10   MSCBUTIL                                                              02/19/2008 13:55:17 PAGE 31  

                 DAC1L = 0;
                 DAC1H = 0;
              
                 delay_us(10); // wait for DAC
              }
              
              /*------------------------------------------------------------------*/
              
              void rtc_write_byte(unsigned char adr, unsigned char d)
              {
                 RTC_CLK = 0;
                 SFRPAGE = DAC1_PAGE;
                 DAC1L = 0xFF;
                 DAC1H = 0x0F;
              
                 delay_us(10); // wait for DAC
              
                 /* switch port to output */
                 SFRPAGE = CONFIG_PAGE;
                 P1MDOUT |= 0x04; 
              
                 rtc_output(adr);
                 rtc_output(d);
              
                 SFRPAGE = DAC1_PAGE;
                 DAC1L = 0;
                 DAC1H = 0;
              
                 delay_us(10); // wait for DAC
              }
              
              /*------------------------------------------------------------------*/
              
              void rtc_write(unsigned char d[6])
              {
                 RTC_CLK = 0;
                 SFRPAGE = DAC1_PAGE;
                 DAC1L = 0xFF;
                 DAC1H = 0x0F;
              
                 delay_us(10); // wait for DAC
              
                 /* switch port to output */
                 SFRPAGE = CONFIG_PAGE;
                 P1MDOUT |= 0x04; 
              
                 rtc_output(0xBE); // clock burst write
              
                 rtc_output(d[5]);     // sec
                 rtc_output(d[4]);     // min
                 rtc_output(d[3]);     // hour
                 rtc_output(d[0]);     // date
                 rtc_output(d[1]);     // month
                 rtc_output(1);        // weekday
                 rtc_output(d[2]);     // year
                 rtc_output(0);        // WP
              
                 SFRPAGE = DAC1_PAGE;
                 DAC1L = 0;
                 DAC1H = 0;
              
                 delay_us(10); // wait for DAC
C51 COMPILER V8.10   MSCBUTIL                                                              02/19/2008 13:55:17 PAGE 32  

              }
              
              /*------------------------------------------------------------------*/
              
              void rtc_write_item(unsigned char item, unsigned char d)
              {
                 switch (item) {
                    case 0: rtc_write_byte(0x86, d); break; // day
                    case 1: rtc_write_byte(0x88, d); break; // month
                    case 2: rtc_write_byte(0x8C, d); break; // year
                    case 3: rtc_write_byte(0x84, d); break; // hour
                    case 4: rtc_write_byte(0x82, d); break; // minute
                    case 5: rtc_write_byte(0x80, d); break; // second
                 }
              }
              
              /*------------------------------------------------------------------*/
              
              void rtc_conv_date(unsigned char d[6], char *str)
              {
                 if (d[0] == 0xFF) { // no clock mounted
                    str[0] = str[1] = str[3] = str[4] = str[6] = str[7] = '?';
                    str[2] = str[5] = '-';
                    str[8] = 0;
                    return;
                 }
                 str[0] = '0'+d[0]/0x10;
                 str[1] = '0'+d[0]%0x10;
                 str[2] = '-';
              
                 str[3] = '0'+d[1]/0x10;
                 str[4] = '0'+d[1]%0x10;
                 str[5] = '-';
              
                 str[6] = '0'+d[2]/0x10;
                 str[7] = '0'+d[2]%0x10;
                 str[8] = 0;
              }
              
              /*------------------------------------------------------------------*/
              
              void rtc_conv_time(unsigned char d[6], char *str)
              {
                 if (d[0] == 0xFF) { // no clock mounted
                    str[0] = str[1] = str[3] = str[4] = str[6] = str[7] = '?';
                    str[2] = str[5] = ':';
                    str[8] = 0;
                    return;
                 }
                 str[0] = '0'+d[3]/0x10;
                 str[1] = '0'+d[3]%0x10;
                 str[2] = ':';
              
                 str[3] = '0'+d[4]/0x10;
                 str[4] = '0'+d[4]%0x10;
                 str[5] = ':';
              
                 str[6] = '0'+d[5]/0x10;
                 str[7] = '0'+d[5]%0x10;
                 str[8] = 0;
              }
              
C51 COMPILER V8.10   MSCBUTIL                                                              02/19/2008 13:55:17 PAGE 33  

              /*------------------------------------------------------------------*/
              
              void rtc_print()
              {
                 unsigned char xdata d[6];
                 char xdata str[10];
              
                 rtc_read(d);
                 if (d[0] != 0xFF) {
                    rtc_conv_date(d, str);
                    puts(str);
                    puts("  ");
                    rtc_conv_time(d, str);
                    puts(str);
                 }
              }
              
              /*------------------------------------------------------------------*/
              
              unsigned char rtc_present()
              {
                 unsigned char d;
              
                 d = rtc_read_byte(0);
                 return d != 0xFF;
              }
              
              /*------------------------------------------------------------------*/
              
              void rtc_init()
              {
                 /* remove write protection */
                 rtc_write_byte(0x8E, 0);
              }
              
              #endif // HAVE_RTC
2011          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1793    ----
   CONSTANT SIZE    =    266    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     12      38
   IDATA SIZE       =      4      10
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
